[
    "(:action gather ; Collect an item from the environment and add it to the inventory\n  :parameters (?agent - agent ?item - object ?location - place)\n  :precondition (and (at ?agent ?location) (at ?item ?location) (not (in_inventory ?agent ?item)))\n  :effect (in_inventory ?agent ?item))",
    "(:action push ; Push an item away from a container\n:parameters (?p - person ?container - container ?item - object)\n:precondition (and (inventory ?p ?container) (inventory ?p ?item) (threaded ?item ?container))\n:effect (pushed_away ?item ?container))\n\nThis merged action, \"push\", is designed to be general and adaptable to various tasks involving pushing an item away from a container. It maintains logical consistency, with preconditions ensuring that the person has both the container and item in their inventory and that the item is threaded to the container. The effect reflects the state change of the item being pushed away from the container.",
    "To merge the given actions into a single universal `slide` action while adhering to the provided guidelines, we aim to generalize the parameters and ensure logical consistency, simplicity, and adaptability for a wide variety of tasks. Here's the merged action:\n\n---\n\n### Merged Action: `slide`\n```pddl\n(:action slide ; Slide an object to adjust its position or state\n    :parameters (?actor - agent ?object - movable ?surface - surface)\n    :precondition (and (in_inventory ?actor ?surface) (pushed_away ?object ?surface))\n    :effect (and (slid ?object ?surface))\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n1. **Generality**:\n   - The parameters are generalized to represent an `actor` (e.g., a player or agent), an `object` (e.g., squares, boxes, or other movable items), and a `surface` (e.g., hanger or another interface). This ensures that the action is adaptable to a variety of tasks involving sliding or repositioning objects.\n   \n2. **State Change**:\n   - The `precondition` ensures that the actor has the required surface in their inventory and that the object is in a state where it can be pushed away.\n   - The `effect` reflects the state change, marking the object as having been slid relative to the surface.\n\n3. **Core Logic**:\n   - The core logic of the original actions (`slide_squares`) is preserved. The agent needs to have the appropriate tools or surface (`inventory ?actor ?surface`) and the object must be in the correct initial state (`pushed_away ?object ?surface`) before the slide action can occur.\n\n4. **Avoid Redundancy**:\n   - Similar effects across the original actions are merged into a single effect (`slid ?object ?surface`), without any unnecessary complexity or duplication.\n\n5. **Logical Consistency**:\n   - The merged action maintains consistency in its preconditions and effects, ensuring that it is applicable in a wide variety of contexts where sliding or repositioning objects is required.\n\n---\n\n### How the Merged Action Applies:\n- In the original `slide_squares` action, the `hanger` acts as the `surface`, and the `squares` act as the `object`. This mapping allows the merged action to retain the same functionality while being more abstract and flexible.\n- The action can now be used for sliding any movable object on any surface by any agent, not just limited to squares and hangers.\n\n",
    "Based on the provided examples and the guidelines to merge multiple PDDL actions into a single universal action, here is the merged action named `finish`:\n\n```lisp\n(:action finish ; Complete a task involving assembling and finalizing an item\n :parameters (?actor - person ?item1 - object ?item2 - object ?final_item - object)\n :precondition (and (inventory ?actor ?item1) (inventory ?actor ?item2) (not (finished ?final_item)))\n :effect (and (at ?final_item ?actor) (not (inventory ?actor ?item1)) (not (inventory ?actor ?item2)) (finished ?final_item)))\n)\n```\n\n**Explanation:**\n\n1. **Generality:** The merged action `finish` uses abstract parameters (`?actor`, `?item1`, `?item2`, `?final_item`) to adapt to various contexts, making it applicable to multiple tasks involving assembling and finalizing an item.\n2. **State Change:** Preconditions and effects are clearly defined to reflect the changes in state:\n   - **Preconditions:** The actor must have the required items (`?item1` and `?item2`) in their inventory and the final item must not be finished yet.\n   - **Effects:** The final item is now with the actor (`at ?final_item ?actor`), the required items are removed from the actor's inventory, and the final item is marked as finished (`finished ?final_item`).\n3. **Simplicity:** The action avoids redundancy by combining similar effects into a single, clear action.\n4. **Logical Consistency:** The action maintains consistent logic, ensuring that the preconditions and effects are clear and reasonable in different contexts.\n\nThis merged action captures the core logic of the provided steps while remaining adaptable to a variety of tasks.",
    "(:action untwist ; Untwist an object and update its state\n  :parameters (?p - entity ?object - twistable ?tool - tool)\n  :precondition (and (inventory ?p ?object) (inventory ?p ?tool) (twisted ?object))\n  :effect (and (not (twisted ?object)) (normal_shape ?object))\n)\n\nThis merged action is designed to be general and adaptable to a variety of tasks that involve untwisting objects. It uses abstract parameters to ensure broad applicability, clearly describes the state change, retains core logic, avoids redundancy, and maintains logical consistency across different contexts."
]