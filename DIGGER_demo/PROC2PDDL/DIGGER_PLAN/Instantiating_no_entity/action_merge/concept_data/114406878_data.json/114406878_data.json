[
    "Given the provided guidelines and the example actions, we'll create a merged action for the \"cluster\" task. The merged action should be general, adaptable, and avoid redundancy while maintaining logical consistency.\n\n### Merged Action: cluster\n\n```pddl\n(:action cluster\n  :parameters (?entity1 - entity ?entity2 - entity)\n  :precondition (and \n                  (not (clustered ?entity1))\n                  (not (clustered ?entity2))\n                )\n  :effect (and \n            (clustered ?entity1)\n            (clustered ?entity2)\n          )\n)\n```\n\n### Explanation:\n\n- **Generality**: The parameters are defined as abstract entities (`?entity1` and `?entity2`), which can represent any objects to be clustered, not limited to grass or grass tinder.\n- **State Change**: The preconditions ensure that neither of the entities is already clustered. The effects update the state to reflect that both entities are now clustered.\n- **Simplicity**: The merged action is kept simple by using general terms and avoiding unnecessary complexity.\n- **Logical Consistency**: The preconditions and effects are logically consistent, ensuring that the action is applicable in various contexts where clustering of entities is required.\n\nThis merged action should be adaptable to multiple clustering tasks, maintaining clarity and efficiency in its execution.",
    "To merge the given PDDL actions into a single, universal action that adheres to your guidelines, we'll abstract the parameters and generalize the preconditions and effects. Here's how the merged action would look:\n\n```lisp\n(:action get ; Collect a resource and update its status\n  :parameters (?agent - entity ?resource - object)\n  :precondition (and\n                  (not (collected ?resource))\n                  (source_of ?resource)\n                )\n  :effect (collected ?resource)\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The action is named \"get\", which is a general term for acquiring or collecting resources.\n   - The parameters are generalized to `?agent - entity` and `?resource - object` to apply to various entities (e.g., NPCs, players) and objects (e.g., water, tinder, kindling).\n\n2. **State Change**: \n   - The precondition ensures the resource is not yet collected and that there is a source for the resource, which is a common requirement for collecting any type of resource.\n   - The effect reflects that the resource is now collected, transforming the state of that resource.\n\n3. **Simplicity**:\n   - By using a single precondition `(source_of ?resource)`, it accounts for any necessary context that makes the resource available for collection, thereby removing redundancy.\n\n4. **Logical Consistency**:\n   - The logic of checking whether a resource is already collected and ensuring a source exists before collecting is consistent across different types of resources and tasks.\n\nThis merged action can be adapted to various scenarios involving collecting or acquiring different types of resources by different agents.",
    "Given the objective of merging multiple PDDL actions into a single universal action, let's consider the provided actions and combine them following the guidelines of generality, state change, core logic, avoiding redundancy, and logical consistency.\n\nHere is the merged action named \"start\":\n\n### Merged Action: start\n\n```pddl\n(:action start\n    :parameters (?actor - entity ?resource - object ?location - place)\n    :precondition (and \n                    (available ?actor) \n                    (at ?actor ?location)\n                    (clustered ?resource)\n                    (not (started ?resource ?location))\n                  )\n    :effect (started ?resource ?location)\n)\n```\n\n### Breakdown of the Merged Action:\n\n1. **Generality**: This action uses abstract parameters (`?actor`, `?resource`, `?location`) which can represent a variety of entities, objects, and places, making it adaptable to multiple tasks.\n   \n2. **State Change**: The preconditions and effects clearly describe the state change, ensuring that the action is only performed if the resource is clustered and not yet started, and then it marks the resource as started in the specified location.\n\n3. **Core Logic**: The core logic of preconditions and effects from the provided actions is retained without unnecessary complexity.\n\n4. **Avoid Redundancy**: Actions with similar effects are merged efficiently. For example, starting a fire and breaking a branch can be universally captured as starting or initiating a resource within a location.\n\n5. **Logical Consistency**: The merged action maintains consistent logic across different tasks, ensuring that the preconditions and effects are reasonable and clear. \n\nBy following these guidelines, we achieve a simple, efficient, and adaptable action definition that can be used for various tasks involving checking, modifying, or creating states.",
    "To merge the actions related to \"breaking\" into a single, universal action, we'll need to follow the guidelines you provided. We'll ensure that the merged action is abstract, maintains logical consistency, and clearly defines state changes without redundancy. Here is how the merged action might look:\n\n```pddl\n(:action break ; Break an object and update its status\n  :parameters (?entity - entity ?object - object)\n  :precondition (and (not (broken ?object)))\n  :effect (broken ?object)\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The parameters are abstracted to `?entity` and `?object` to allow flexibility across different tasks or contexts. This could apply to breaking a branch, a piece of equipment, or any object in various scenarios.\n\n2. **State Change**:\n   - The precondition ensures that the object is not already broken, and the effect updates the state to reflect that the object is now broken.\n\n3. **Core Logic**:\n   - The core logic of checking whether an object is already broken and then marking it as broken is retained.\n\n4. **Avoid Redundancy**:\n   - Since the task is about breaking, we've kept the action simple and focused on changing the state from not broken to broken.\n\n5. **Logical Consistency**:\n   - The action maintains a clear and consistent logic that can be applied to different contexts where breaking an object is required.\n\nThis merged action should be adaptable to a variety of tasks that involve changing the state of an object to broken, while being simple and logically consistent.",
    "To merge the given PDDL actions into a single, universal \"build\" action, we need to consider the guidelines mentioned: generality, state change, simplicity, and logical consistency. Let's analyze the provided actions and create a merged action that is abstract enough to cover various building tasks while maintaining the core logic of the original actions.\n\n### Merged Action: `build`\n\n```pddl\n(:action build\n    :parameters (?builder - agent ?location - place ?structure - structure_type ?resource - resource_type)\n    :precondition (and\n                    (not (built ?structure))\n                    (available ?builder)\n                    (available ?resource)\n                    (at ?builder ?location)\n                    (prepared ?resource ?structure)\n                  )\n    :effect (and\n             (built ?structure)\n             (not (available ?resource))\n             (completed_task ?builder ?structure)\n           )\n)\n```\n\n### Explanation:\n\n- **Generality**: The merged action uses abstract parameters like `?builder`, `?location`, `?structure`, and `?resource` to apply to various building scenarios, making it adaptable for different types of constructions.\n\n- **State Change**: The preconditions ensure the builder is available, the necessary resources are prepared and available, and the builder is at the correct location. The effect reflects the state change by marking the structure as built, consuming the resource, and marking the task as completed.\n\n- **Simplicity**: By combining similar actions and removing unnecessary complexity, the merged action avoids redundancy while maintaining clarity and efficiency.\n\n- **Logical Consistency**: The preconditions and effects are kept reasonable and clear, maintaining logical consistency across different tasks. The `prepared ?resource ?structure` predicate ensures that necessary preparations (like clustering, breaking, or starting a fire) are completed before building.\n\nThis merged action captures the essence of building tasks, adaptable to various scenarios by leveraging abstract parameterization and ensuring clear state transitions from preconditions to effects.",
    "To create a merged action named \"burn\" that combines the given actions while adhering to the guidelines of generality, state change, simplicity, and logical consistency, we need to abstract the parameters and maintain the core logic of preconditions and effects. Here's how the merged action could be structured:\n\n```lisp\n(:action burn ; Burn a combustible resource\n :parameters (?agent - agent ?combustible - object ?context - context)\n :precondition (and\n                 (not (burned ?combustible))\n                 (fire_started ?context)\n                 (can_interact ?agent ?combustible)\n               )\n :effect (burned ?combustible)\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The parameters are generalized as `?agent`, `?combustible`, and `?context`. This allows the action to apply to various agents (like persons or tools) and objects (like wood, paper, etc.) in different contexts (such as environments or situations where burning is possible).\n\n2. **State Change**: \n   - The precondition `(not (burned ?combustible))` ensures that the object has not already been burned.\n   - The precondition `(fire_started ?context)` indicates that a fire must be present or initiated in the given context.\n   - The effect `(burned ?combustible)` represents the transformation of the object's state from unburned to burned.\n\n3. **Simplicity**: \n   - Redundancy is avoided by using a single universal action for burning, instead of separate actions for different types of combustible materials.\n\n4. **Logical Consistency**: \n   - The precondition `(can_interact ?agent ?combustible)` ensures that the agent is capable of interacting with the combustible object, maintaining consistency and reasonableness across different scenarios.\n\nBy following these guidelines, the merged \"burn\" action can be applied to a wide range of tasks involving the burning of various objects, while maintaining clarity and effectiveness."
]