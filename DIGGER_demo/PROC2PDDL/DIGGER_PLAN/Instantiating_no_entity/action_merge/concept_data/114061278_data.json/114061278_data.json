[
    "To merge the given actions into a single universal action named \"poke,\" we need to create a generalized form that encapsulates the essence of poking a coconut using the tools, while maintaining logical consistency, simplicity, and adaptability to various scenarios.\n\nHere's the merged action:\n\n```lisp\n(:action poke ; Poke an object using tools and update its status\n    :parameters (?npc - person ?obj - object ?tool1 - tool ?tool2 - tool)\n    :precondition (and (drained ?obj) (available ?tool1) (available ?tool2) (not (poked ?obj)))\n    :effect (and (poked ?obj) (not (intact ?obj)))\n)\n```\n\nExplanation:\n\n1. **Generality**: The action is named \"poke\" and uses abstract parameters (?npc, ?obj, ?tool1, ?tool2) to be adaptable to various tasks, including but not limited to coconuts and the specific tools mentioned.\n\n2. **State Change**: The preconditions ensure that the object is drained and the tools are available, and the effect clearly reflects the change in the object's state by marking it as \"poked\" and \"not intact.\"\n\n3. **Simplicity**: Unnecessary complexity is avoided by consolidating the effects into a single transformation of the object's state, removing overlapping conditions like \"hole_poked\" and \"hole_in_eye\" in favor of a more general \"poked\" status.\n\n4. **Logical Consistency**: The preconditions and effects are logically consistent across different contexts, ensuring that the action can be applied to similar scenarios involving poking an object with tools.",
    "To merge the provided actions into a single universal action named \"drain\" that can handle various scenarios involving the draining process, we'll need to generalize the parameters and unify the preconditions and effects logically. Here\u2019s the merged action:\n\n```pddl\n(:action drain\n    :parameters (?npc - person ?item1 - object ?item2 - object ?loc - location)\n    :precondition (and \n                    (available ?npc)\n                    (at ?item1 ?loc)\n                    (or (not (drained ?item1))\n                        (and (full ?item1) (empty ?item2) (upside_down ?item1))\n                        (and (screwdriver_inserted ?item2 ?item1) (coconut_eye_poked ?item1)))\n                   )\n    :effect (and \n              (drained ?item1)\n              (or (full ?item2) (not (full ?item1)))\n              (not (screwdriver_inserted ?item2 ?item1))\n              (coconut_eye_widened ?item1)\n            )\n)\n```\n\n### Explanation:\n- **Parameters**: The parameters are generalized to `?npc`, `?item1`, `?item2`, and `?loc` to increase the applicability of the action across different tasks.\n- **Preconditions**: The preconditions cover various scenarios:\n  - Checking if the `?npc` is available.\n  - Ensuring the `?item1` (e.g., coconut) is at the specified location.\n  - Handling three scenarios:\n    - The item has not been drained yet.\n    - The item is full, the second item (e.g., glass) is empty, and the item is upside down.\n    - The screwdriver is inserted, and the coconut eye is poked.\n- **Effects**: The effects reflect the changes in the state:\n  - Marking the item as drained.\n  - Handling the transition of states when draining the liquid into another item.\n  - Removing the screwdriver and widening the coconut eye.\n\nThis merged action maintains generality, avoids redundancy, and ensures logical consistency across different contexts involving the draining process.",
    "(:action break_resource\n  :parameters (?npc - person ?resource - object ?tool - object ?wrap - object)\n  :precondition (and\n                    (wrapped ?resource ?wrap)\n                    (not (broken ?resource))\n                    (available ?npc)\n                  )\n  :effect (and\n            (broken ?resource)\n            (not (wrapped ?resource ?wrap))\n          )\n)",
    "(:action wrap\n  :parameters (?agent - agent ?item - object ?material - object)\n  :precondition (and\n                  (at ?agent kitchen)\n                  (at ?item kitchen)\n                  (at ?material kitchen)\n                  (or (broken ?item) (hole_in_eye ?item) (hole_poked ?item) (coconut_has_eyes ?item))\n                  (not (wrapped ?item))\n                 )\n  :effect (and\n            (wrapped ?item ?material)\n            (not (unwrapped ?item))\n            (screwdriver_positioned ?material ?item)\n          )\n)\n\nThis merged action, `wrap`, incorporates the core logic and state changes from the provided actions. Here's how it meets the guidelines:\n\n**Generality:** The action uses abstract parameters (?agent, ?item, ?material) to make it adaptable to various tasks involving wrapping an item with a material. The action is not limited to specific object types, ensuring broader applicability.\n\n**State Change:** The preconditions clearly reflect the state requirements for wrapping (e.g., item location, item condition). The effects indicate the transformation of the item's state (e.g., wrapped, not unwrapped, screwdriver positioned).\n\n**Simplicity:** The merged action avoids redundancy by combining similar preconditions and effects, making it efficient and straightforward.\n\n**Logical Consistency:** The preconditions and effects are logically consistent across different contexts, ensuring that the action remains reasonable and clear in various scenarios.",
    "To merge the actions related to creating a hole in a coconut into a single universal action, we need to generalize the parameters, maintain clear state changes, and avoid redundancy. Here is the resulting merged action:\n\n```lisp\n(:action bore\n    :parameters (?person - person ?tool1 - tool ?tool2 - tool ?target - object)\n    :precondition (and\n                    (tool_positioned ?tool1 ?target)\n                    (not (target_modified ?target))\n                   )\n    :effect (and\n              (target_modified ?target)\n              (tool_used ?tool1 ?target)\n            )\n)\n```\n\n### Explanation:\n\n1. **Generality**: The action is named \"bore\" to represent the general act of creating or modifying a hole. The parameters are abstracted to `?person`, `?tool1`, `?tool2`, and `?target`, making this action adaptable to various tasks involving tools and target objects.\n   \n2. **State Change**: The action's preconditions clearly indicate that the first tool needs to be positioned on the target and that the target has not yet been modified. The effects show that the target is modified and the first tool is used, clearly reflecting the change in state.\n\n3. **Simplicity**: The action avoids redundancy by only requiring the necessary conditions and effects for creating a hole or modifying the target. Additional details about specific tools (like `screwdriver` and `mallet`) are abstracted away, ensuring simplicity.\n\n4. **Logical Consistency**: The preconditions and effects are logically consistent across different contexts, maintaining clarity and reasonableness in the action's logic.\n\nThis merged action can now be applied to various scenarios where a person uses tools to modify a target object, not limited to just creating holes in coconuts but potentially other similar tasks."
]