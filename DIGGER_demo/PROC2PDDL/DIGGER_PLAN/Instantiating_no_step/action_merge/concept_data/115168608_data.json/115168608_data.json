[
    "Certainly! Let's merge the actions into a single universal action named `move`. This action will capture the movement of an agent to a specified location, while ensuring that the preconditions and effects are generalized and consistent.\n\n### Action sets that need to be merged:\n1. **move_to_storage_room**\n```pddl\n(:action move_to_storage_room\n    :parameters (?a - agent ?r - room)\n    :precondition (and\n      (at ?a ?current_location)\n      (is_storage_room ?r)\n    )\n    :effect (and\n      (not (at ?a ?current_location))\n      (at ?a ?r)\n    )\n)\n```\n\n2. **locate_required_material**\n```pddl\n(:action locate_required_material\n    :parameters (?a - agent ?m - material ?r - room)\n    :precondition (and\n      (at ?a ?current_location)\n      (material_location ?m ?r)\n    )\n    :effect (and\n      (not (at ?a ?current_location))\n      (at ?a ?r)\n      (located ?a ?m)\n    )\n)\n```\n\n### The merged action:\n\n```pddl\n(:action move\n    :parameters (?a - agent ?r - room ?m - object)\n    :precondition (and\n      (at ?a ?current_location)\n      (or (is_storage_room ?r) (material_location ?m ?r))\n    )\n    :effect (and\n      (not (at ?a ?current_location))\n      (at ?a ?r)\n      (when (material_location ?m ?r) (located ?a ?m))\n    )\n)\n```\n\n### Breakdown:\n\n- **Generality**: The merged action `move` is designed to be adaptable to various tasks involving movement to a room, whether it is a storage room or the location of a required material.\n- **State Change**: The preconditions ensure that the agent is currently at a particular location and that the destination is a valid room (either a storage room or a material location). The effects capture the movement by updating the agent's location and, if applicable, marking the agent as having located the material.\n- **Core Logic**: The core logic of preconditions and effects from the original actions is retained, ensuring that the agent's movement is handled appropriately.\n- **Avoid Redundancy**: Similar effects from the original actions are merged to keep the action simple and efficient.\n- **Logical Consistency**: The action maintains logical consistency by ensuring the preconditions and effects are reasonable and applicable in different contexts.\n\nThe merged `move` action now captures the essence of both movement to a storage room and locating a required material, making it a versatile and efficient action for various scenarios.",
    "Based on your provided guidelines and the example actions, here is the merged action for the \"pick\" task:\n\n```pddl\n(:action pick ; Pick a resource and update its location status\n    :parameters (?agent - agent ?item - object ?location - location)\n    :precondition (and\n        (at ?agent ?location)\n        (located ?item ?location)\n        (not (carrying ?agent ?item))\n    )\n    :effect (and\n        (carrying ?agent ?item)\n        (not (located ?item ?location))\n    )\n)\n```\n\nExplanation:\n- **Generality**: The merged action uses abstract parameters (`?agent`, `?item`, `?location`) to ensure it can be applied to various tasks involving agents picking up items from specific locations.\n- **State Change**: The action clearly describes the state change from the item being located in a particular place to being carried by the agent.\n- **Simplicity**: The action is straightforward and avoids unnecessary complexity, focusing only on the essential preconditions and effects.\n- **Logical Consistency**: The action maintains consistent logic and reasonable preconditions and effects, ensuring clarity in different contexts.\n\nThis merged action captures the essence of the provided actions related to picking up items and updating their status accordingly.",
    "To merge the given actions into a universal action named \"bring,\" we will abstract the parameters and consolidate the core logic, ensuring generality, simplicity, and logical consistency. The merged action should accommodate a variety of tasks involving moving an item from one location to another.\n\n### Merged Action: Bring\n\n```pddl\n(:action bring\n    :parameters (?agent - entity ?item - object ?from - location ?to - location)\n    :precondition (and\n        (at ?agent ?from)\n        (carrying ?agent ?item)\n    )\n    :effect (and\n        (not (at ?agent ?from))\n        (at ?agent ?to)\n        (in ?item ?to)\n        (not (carrying ?agent ?item))\n    )\n)\n```\n\n### Explanation:\n\n1. **Generality**: The action is named \"bring\" and uses abstract parameters (`?agent`, `?item`, `?from`, `?to`) to ensure the action can be applied to any entity carrying an object from one location to another.\n\n2. **Preconditions**: \n   - `(at ?agent ?from)`: Ensures the agent is at the starting location.\n   - `(carrying ?agent ?item)`: Confirms that the agent has the item.\n\n3. **Effects**:\n   - `(not (at ?agent ?from))`: The agent is no longer at the starting location.\n   - `(at ?agent ?to)`: The agent arrives at the destination.\n   - `(in ?item ?to)`: The item is placed at the destination.\n   - `(not (carrying ?agent ?item))`: The agent is no longer carrying the item.\n\n4. **Simplicity and Logical Consistency**: The action is straightforward, avoids redundancy, and maintains logical consistency by ensuring that the parameters, preconditions, and effects are adaptable to different contexts involving the transfer of items between locations. This universal \"bring\" action can be applied to various tasks beyond the specific scenarios initially described.",
    "To create a merged PDDL action named \"select\" that is adaptable to a variety of tasks, we need to ensure that it captures the core logic and state changes of the provided actions while maintaining simplicity and logical consistency. Below is the merged action:\n\n```lisp\n(:action select ; Select a resource or area and update its status\n  :parameters (?agent - entity ?resource - object)\n  :precondition (and (not (selected ?resource)))\n  :effect (selected ?resource)\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The action uses abstract parameters `?agent` and `?resource`, which can represent a wide range of entities and objects, making the action applicable to various contexts beyond the specific scenarios of selecting an area or gathering papyrus.\n\n2. **State Change**:\n   - The precondition checks that the resource (or area) is not already selected, ensuring the action can only be executed if the resource is unselected.\n   - The effect marks the resource as selected, clearly reflecting the state change and progressing towards a goal state.\n\n3. **Core Logic**:\n   - The action retains the essential logic of the original actions, focusing on selecting a resource and updating its status without adding unnecessary complexity.\n\n4. **Avoid Redundancy**:\n   - By merging similar actions, we ensure simplicity and avoid redundancy, combining the logic of selecting an area and gathering a resource into a single action.\n\n5. **Logical Consistency**:\n   - The action maintains consistent logic across different tasks, ensuring that preconditions and effects are reasonable and clear in various contexts.\n\nThis merged action can now be applied to select any kind of resource or area in a planning problem, providing a flexible and efficient way to handle tasks involving selection and status updates.",
    "Combining the given actions \"wet-sponge\" and \"gather_papyrus_plant\" into a single universal action \"wet\" involves creating a more abstract action that can handle similar state changes for different entities. Here is an example of a merged action:\n\n```lisp\n(:action wet\n  :parameters (?entity - object)\n  :precondition (and (dry ?entity) (on-ground ?entity))\n  :effect (and (wet ?entity) (in-container ?entity))\n)\n```\n\n**Explanation**: \n- **Generality**: The action is generalized to apply to any `object` (not just a sponge), making it adaptable to various tasks that involve wetting an entity.\n- **State Change**: The precondition ensures the entity is dry and on the ground, and the effect makes it wet and places it in a container.\n- **Simplicity**: The action avoids redundancy and unnecessary complexity by focusing on the core logic of the state change.\n- **Logical Consistency**: The merged action maintains reasonable preconditions and effects that would apply in different contexts where an entity needs to be wetted.\n\nThis universal \"wet\" action can be used in scenarios involving different objects that need to be wetted as part of their processing.",
    "To create a merged PDDL action named \"camouflage\" that follows the guidelines of generality, state change, simplicity, and logical consistency, we can abstract the parameters and retain the core logic of preconditions and effects. Below is the merged action:\n\n```pddl\n(:action camouflage\n    :parameters (?entity - object ?agent - agent)\n    :precondition (and (plain ?entity) (visible ?agent))\n    :effect (and (camouflaged ?entity) (invisible ?agent))\n)\n```\n\n**Explanation**:\n- **Generality**: The parameters have been abstracted to `?entity` and `?agent` to allow this action to be applied to a variety of objects beyond just helmets and NPCs. This makes the action adaptable to different tasks where an item needs to be camouflaged and an agent made invisible.\n  \n- **State Change**: The preconditions and effects clearly depict a transformation: an entity that is initially plain is camouflaged, and an agent that is initially visible becomes invisible.\n  \n- **Simplicity**: The action is straightforward, with a single effect derived from the specified preconditions. It avoids redundancy and unnecessary complexity by focusing on the core logic needed to achieve the desired state change.\n\n- **Logical Consistency**: The preconditions and effects maintain consistent logic across different contexts by ensuring that the action is only applied when the relevant conditions (plain entity and visible agent) are met, and the outcomes are logically coherent (camouflaged entity and invisible agent).",
    "(:action locate\n    :parameters (?a - agent ?i - item ?r - room)\n    :precondition (and\n      (at ?a ?r)\n      (is_storage_room ?r)\n      (in ?i ?r)\n    )\n    :effect (and\n      (located ?a ?i)\n    )\n)\n\n(:action pick_up\n    :parameters (?a - agent ?i - item ?r - room)\n    :precondition (and\n      (at ?a ?r)\n      (located ?a ?i)\n    )\n    :effect (and\n      (has ?a ?i)\n      (not (located ?a ?i))\n    )\n)"
]