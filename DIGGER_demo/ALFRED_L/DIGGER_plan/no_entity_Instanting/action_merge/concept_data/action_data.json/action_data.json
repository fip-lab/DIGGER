[
    "Here is the universal merged action that combines the functionality of all the provided actions into a single, generalized and reusable format. This action leverages abstract parameters, consistent state changes, and avoids redundancy while maintaining logical consistency:\n\n```lisp\n(:action universal_action\n  :parameters (?agent - agent ?entity - object ?from - location ?to - location ?receptacle - receptacle)\n  :precondition (and\n                  ;; Preconditions for movement\n                  (at ?agent ?from)\n                  (connected ?from ?to)\n\n                  ;; Preconditions for picking up an object\n                  (or (and (at ?entity ?from) (not (holding ?agent ?entity)))\n                      (not (exists (?entity - object) (at ?entity ?from))))\n\n                  ;; Preconditions for placing an object\n                  (or (and (holding ?agent ?entity) (at ?receptacle ?to))\n                      (not (exists (?entity - object) (holding ?agent ?entity)))))\n\n  :effect (and\n            ;; Effects of movement\n            (at ?agent ?to)\n            (not (at ?agent ?from))\n\n            ;; Effects of picking up an object\n            (when (and (at ?entity ?from) (not (holding ?agent ?entity)))\n              (and (holding ?agent ?entity) (not (at ?entity ?from))))\n\n            ;; Effects of placing an object\n            (when (and (holding ?agent ?entity) (at ?receptacle ?to))\n              (and (in ?entity ?receptacle) (not (holding ?agent ?entity))))))\n```\n\n---\n\n### Explanation of the Merged Action:\n\n1. **Generality:**\n   - The `universal_action` is adaptable to multiple tasks, including moving an agent, picking up an object, and placing an object into a receptacle. Abstract parameters (`?agent`, `?entity`, etc.) make it flexible for various contexts.\n\n2. **State Change:**\n   - The preconditions and effects are designed to capture the state change at each step:\n     - Movement: Updates the agent's location.\n     - Picking up an object: Changes the state of the object from being at a location to being held by the agent.\n     - Placing an object: Changes the state of the object from being held by the agent to being inside a receptacle.\n\n3. **Simplicity:**\n   - Redundant or repetitive actions (e.g., `move_agent`, `pickup_object`, `put_object`) are merged into a single action with conditional effects, reducing complexity and improving efficiency.\n\n4. **Logical Consistency:**\n   - Preconditions ensure that the action is logically valid in all contexts:\n     - An agent can only move if the target location is connected to the current location.\n     - An agent can only pick up an object if it is at the same location and the agent is not already holding it.\n     - An agent can only place an object if it is holding the object and the receptacle is at the target location.\n\n5. **Avoiding Redundancy:**\n   - By combining movement, pickup, and placement into a single action, redundancy is minimized without sacrificing modularity. Each sub-task is represented as a conditional branch within the action.\n\n---\n\n### Examples of Usage:\n\n1. **Move Agent:**\n   ```lisp\n   (:action universal_action\n    :parameters (?agent - agent ?from - location ?to - location)\n    :precondition (and (at ?agent ?from) (connected ?from ?to))\n    :effect (and (at ?agent ?to) (not (at ?agent ?from))))\n   ```\n\n2. **Pickup Object:**\n   ```lisp\n   (:action universal_action\n    :parameters (?agent - agent ?entity - object ?from - location)\n    :precondition (and (at ?agent ?from) (at ?entity ?from) (not (holding ?agent ?entity)))\n    :effect (and (holding ?agent ?entity) (not (at ?entity ?from))))\n   ```\n\n3. **Put Object in Receptacle:**\n   ```lisp\n   (:action universal_action\n    :parameters (?agent - agent ?entity - object ?to - location ?receptacle - receptacle)\n    :precondition (and (holding ?agent ?entity) (at ?receptacle ?to))\n    :effect (and (in ?entity ?receptacle) (not (holding ?agent ?entity))))\n   ```\n\n---\n\n### Key Benefits of the Merged Action:\n- **Efficiency:** Reduces the number of actions required to define similar tasks.\n- **Modularity:** Supports conditional logic to handle different sub-tasks (movement, pickup, placement, etc.).\n- **Scalability:** Can be extended easily for new tasks by adding new conditional branches or effects.\n- **Clarity:** Provides a unified, consistent action definition for multiple scenarios.\n\nThis universal action can now replace all the individual actions while retaining the flexibility to handle diverse tasks in a PDDL-based planning system.",
    "### Merged Action: `put`\nThe merged action consolidates all provided actions related to placing objects into or onto receptacles, ensuring generality, logical consistency, and simplicity.\n\n```lisp\n(:action put\n    :parameters (?agent - agent ?object - object ?receptacle - receptacle)\n    :precondition (and\n                    (holding ?agent ?object)  ;; The agent must be holding the object\n                    (at ?agent ?receptacle)   ;; The agent must be at the receptacle\n                    (accessible ?receptacle) ;; The receptacle must be accessible\n                    (not (prohibited_receptacle ?receptacle)) ;; Receptacle should not be prohibited\n                    (not (in ?object ?receptacle))) ;; The object must not already be in the receptacle\n    :effect (and\n              (in ?object ?receptacle) ;; The object is now in the receptacle\n              (not (holding ?agent ?object)) ;; The agent is no longer holding the object\n              (free_hand ?agent)) ;; The agent's hands are now free\n)\n```\n\n### Explanation of the Merged Action\nThis universal `put` action consolidates all the provided variations of placing objects into or onto receptacles. Here's how it adheres to the guidelines:\n\n1. **Generality**:\n   - The action uses abstract parameters (`?object`, `?receptacle`) that can represent any object or receptacle (e.g., books, pens, keychains, sofas, boxes).\n   - Checks for prohibited receptacles and ensures compatibility across tasks.\n\n2. **State Change**:\n   - Preconditions ensure the agent is holding the object and is at the location of the receptacle.\n   - Effects clearly define the state change: the object is now in the receptacle, and the agent is no longer holding the object.\n\n3. **Simplicity**:\n   - The action removes redundancies by consolidating all similar actions into one.\n   - Instead of defining multiple actions for specific objects or receptacles, this single action applies broadly.\n\n4. **Logical Consistency**:\n   - Preconditions like `accessible ?receptacle` and `not (prohibited_receptacle ?receptacle)` ensure logical consistency across different contexts.\n   - Effects like `(free_hand ?agent)` ensure tasks can progress without requiring additional actions to free the agent's hands.\n\n---\n\n### Example Use Cases for `put`\n\n1. **Agent places a book on a sofa**:\n   ```lisp\n   (:action put\n       :parameters (?agent - agent ?book - book ?sofa - sofa)\n       :precondition (and\n                       (holding ?agent ?book)\n                       (at ?agent ?sofa)\n                       (accessible ?sofa))\n       :effect (and\n                 (in ?book ?sofa)\n                 (not (holding ?agent ?book))\n                 (free_hand ?agent)))\n   ```\n\n2. **Agent puts a keychain in a box**:\n   ```lisp\n   (:action put\n       :parameters (?agent - agent ?keychain - keychain ?box - box)\n       :precondition (and\n                       (holding ?agent ?keychain)\n                       (at ?agent ?box)\n                       (accessible ?box))\n       :effect (and\n                 (in ?keychain ?box)\n                 (not (holding ?agent ?keychain))\n                 (free_hand ?agent)))\n   ```\n\n3. **Agent places a pen on a sofa, avoiding box2**:\n   ```lisp\n   (:action put\n       :parameters (?agent - agent ?pen - pen ?sofa - sofa)\n       :precondition (and\n                       (holding ?agent ?pen)\n                       (at ?agent ?sofa)\n                       (accessible ?sofa)\n                       (not (in ?pen box2)))\n       :effect (and\n                 (in ?pen ?sofa)\n                 (not (holding ?agent ?pen))\n                 (free_hand ?agent)))\n   ```\n\nBy merging actions into this universal `put` action, the planner becomes much more flexible and efficient, capable of handling a variety of object-placement tasks with minimal redundancy.",
    "Here's the merged action for the **`go`** task, combining the various movement-related actions into a single universal action:\n\n---\n\n### Merged Action: `go`\n```lisp\n(:action go ; Move an agent between locations\n    :parameters (?agent - agent ?from - location ?to - location)\n    :precondition (and (at ?agent ?from))\n    :effect (and (at ?agent ?to) (not (at ?agent ?from)))\n)\n```\n\n---\n\n### Explanation of the Merged Action\n\n1. **Generality**:\n   - The merged action is abstract and adaptable to any movement task by using the generic parameters `?agent`, `?from`, and `?to`. This allows it to handle a variety of tasks where an agent moves between locations, such as moving from a desk to a box, a drawer to a box, etc.\n\n2. **State Change**:\n   - The precondition ensures that the agent starts at the `?from` location.\n   - The effect updates the agent's state to reflect that they are now at the `?to` location and no longer at the `?from` location.\n\n3. **Simplicity**:\n   - The merged action avoids redundancy by consolidating all movement-related actions into a single universal action. It eliminates the need to define separate actions for specific movement tasks like \"go_to_location (drawer1 to box1)\" or \"go_to_location (bed1 to drawer1)\".\n\n4. **Logical Consistency**:\n   - The precondition and effect logic is consistent across all contexts where movement is required. The action relies only on the agent's current location (`?from`) and updates it to the new location (`?to`).\n\n---\n\nBy merging all movement-related actions into the single `go` action, we have achieved a universal, adaptable, and efficient representation of movement tasks in PDDL.\n\n",
    "Here is the merged action for \"pick\" after combining the provided actions into a single universal and abstract form:\n\n```lisp\n(:action pick ; Pick up an object or remove it from its current state\n  :parameters (?agent - agent ?object - object ?location - location)\n  :precondition (and\n                 (at ?agent ?location) ; The agent must be at the same location as the object\n                 (in_location ?object ?location) ; The object must be physically in the location\n                 (not (holding ?agent ?object))) ; The agent must not already be holding the object\n  :effect (and\n           (holding ?agent ?object) ; The agent now holds the object\n           (not (in_location ?object ?location))) ; The object is no longer in its original location\n)\n```\n\n### Explanation of the Design:\n1. **Generality**: This action abstracts over the nuances of the original actions (e.g., \"pick_up_object_no_receptacle\" and \"pick_up_object\") by unifying the semantics of \"picking up an object\" into a single action. It doesn't differentiate between objects that are in receptacles or not, as that information can be inferred from the domain model if needed.\n\n2. **State Change**: \n   - **Preconditions**: Ensure the agent and object are co-located, and the agent is not already holding the object.\n   - **Effects**: The agent transitions into a state where they are holding the object, and the object is no longer in its original location.\n\n3. **Simplicity**: Redundant distinctions (e.g., whether the object is \"in_receptacle\" or not) are removed for simplicity. This keeps the action lean and broadly applicable.\n\n4. **Logical Consistency**: The merged action maintains consistent logic across different scenarios, ensuring that the preconditions and effects are reasonable and adaptable.\n\n---\n\n### Additional Notes:\nIf more actions were to be merged into this universal \"pick\" action (e.g., actions involving receptacles or containers), the merged action could be extended further, for example, by adding optional parameters or conditions related to receptacles. However, in this case, the provided actions are already well-aligned for merging into this generalized form.\n\nLet me know if you'd like further assistance with refining the merged actions or designing other universal actions!",
    "Here is the merged action for **prohibit**, following the guidelines provided:\n\n---\n\n### **Merged Action: `prohibit`**\n```lisp\n(:action prohibit ; Prohibit an object from being associated with a specific resource\n    :parameters (?entity - object ?restriction - object)\n    :precondition (not (prohibited ?entity ?restriction))\n    :effect (prohibited ?entity ?restriction)\n)\n```\n\n---\n\n### **Explanation of the Merged Action**\n1. **Generality**:\n   - The `prohibit` action uses abstract parameters (`?entity` and `?restriction`) to accommodate a wide range of tasks, such as prohibiting an object from being placed in a specific receptacle or preventing access to a restricted area.\n   - This generalization ensures that the action is not limited to specific types of objects or constraints.\n\n2. **State Change**:\n   - The precondition ensures that the prohibition does not already exist (`not (prohibited ?entity ?restriction)`), preventing redundancy.\n   - The effect introduces the prohibition (`prohibited ?entity ?restriction`), clearly marking the state change.\n\n3. **Simplicity**:\n   - The merged action avoids unnecessary complexity by unifying similar actions (e.g., `prohibit_receptacle`) under a single, adaptable structure.\n   - This eliminates redundancy and ensures the action is streamlined and efficient.\n\n4. **Logical Consistency**:\n   - The precondition and effect maintain a consistent logical structure across various contexts, ensuring that the action can be reliably applied to different tasks.\n\n---\n\n### **Examples of Usage**\n1. **Prohibit a Phone from Being Placed in a Box**:\n   ```lisp\n   (prohibit cellphone1 box1)\n   ```\n\n2. **Prohibit a Book from Being Placed on a Sofa**:\n   ```lisp\n   (prohibit book1 sofa2)\n   ```\n\n3. **Prohibit a Person from Accessing a Restricted Area**:\n   ```lisp\n   (prohibit person1 restricted_area1)\n   ```\n\n---\n\n### **Final Task Execution Sequence**\n1. **Prohibit Action**:  \n   To ensure the cellphone is not placed in Box3:\n   ```lisp\n   (prohibit cellphone1 box3)\n   ```\n\n2. **Relevant Steps, Streamlined**:\n   - Move the agent to bed1:\n     ```lisp\n     (gotolocation agent1 bed1 sofa2)\n     ```\n   - Pick up the cellphone from bed1:\n     ```lisp\n     (pickupobjectnoreceptacle agent1 cellphone1 bed1)\n     ```\n   - Place the cellphone on sofa2:\n     ```lisp\n     (putobjectinreceptacle agent1 cellphone1 sofa2)\n     ```\n\n---\n\nThis approach ensures that the `prohibit` action is versatile, logically consistent, and adaptable to a variety of tasks, while maintaining an efficient and streamlined execution sequence.",
    "### Final Merged Action: `pickup`\n\nHere is the single universal action that combines the various pickup-related actions into a generalized, reusable structure:\n\n```lisp\n(:action pickup\n    :parameters (?agent - agent ?object - object ?source - location_or_receptacle)\n    :precondition (and\n                    (at ?agent ?source) ; The agent must be at the location/receptacle\n                    (or \n                        (on ?object ?source) ; The object is on the location (e.g., desk, table)\n                        (in ?object ?source) ; The object is inside a receptacle (e.g., drawer, box)\n                        (in_receptacle ?object ?source)) ; Alternative form for receptacle containment\n                    (or\n                        (not (holding ?agent ?object)) ; Agent is not already holding the object\n                        (empty_hand ?agent)) ; Agent has a free hand for pickup\n                    (accessible ?source)) ; The source (location or receptacle) must be accessible\n    :effect (and\n              (holding ?agent ?object) ; Agent is now holding the object\n              (not (on ?object ?source)) ; The object is no longer on the location\n              (not (in ?object ?source)) ; The object is no longer in the receptacle\n              (not (in_receptacle ?object ?source)))) ; Alternative form - object is no longer in source\n```\n\n### Explanation of the Merged Action\nThis merged `pickup` action is designed to be generic and adaptable across a variety of scenarios. Here's how it satisfies the requirements:\n\n1. **Generality**:\n   - The action uses abstract parameters such as `?agent`, `?object`, and `?source`, which can represent any agent, object, or location/receptacle.\n   - It supports picking up objects from both flat surfaces (e.g., desks, tables) and containers (e.g., drawers, boxes).\n\n2. **State Change**:\n   - The `precondition` ensures the agent is at the location and the object is available (on, in, or in_receptacle).\n   - The `effect` captures the state change: the agent is holding the object, and the object is no longer at its source.\n\n3. **Simplicity**:\n   - Redundant variations (e.g., `pickup_object_no_receptacle`, `pickup_pen_from_drawer`, etc.) are merged into a single action with generalized preconditions and effects.\n   - The use of logical `or` operators (`on`, `in`, `in_receptacle`) ensures the action can handle multiple cases without unnecessary duplication.\n\n4. **Logical Consistency**:\n   - Preconditions like `accessible ?source` and `empty_hand ?agent` maintain logical consistency, ensuring the action is valid in different contexts.\n   - Effects like `(not (on ?object ?source))` and `(not (in ?object ?source))` are mutually exclusive, ensuring clarity in state changes.\n\n---\n\n### How the Merged Action Covers All Cases:\n1. **Pickup from a flat surface (e.g., desk)**:\n   - `on ?object ?source` allows for scenarios where the object is on a flat surface.\n   - Example: Picking up a keychain from a desk.\n\n2. **Pickup from a container (e.g., drawer, box)**:\n   - `in ?object ?source` or `in_receptacle ?object ?source` handles objects inside containers.\n   - Example: Picking up a book from a box or a pen from a drawer.\n\n3. **Agent requirements**:\n   - The agent must be at the source location (`at ?agent ?source`) and have a free hand (`empty_hand ?agent`).\n   - Example: Moving to a drawer and picking up a pencil.\n\n4. **Object availability**:\n   - The object\u2019s availability is ensured through conditions like `accessible ?source`.\n\n---\n\n### Benefits of the Merged Action:\n- **Reusable**: The `pickup` action can now be used for a wide variety of tasks involving object retrieval, regardless of the object type or source.\n- **Compact**: Redundant actions have been eliminated, simplifying the action set for easier maintenance.\n- **Extensible**: Additional cases (e.g., picking up objects from new types of sources) can be easily integrated by adding new conditions to the `precondition` and `effect` sections.\n\nThis merged action provides a clean, efficient, and logically consistent way to handle all the pickup-related actions in the given examples.",
    "After merging the actions related to moving and interacting with objects and locations, the resulting universal action can be designed as follows:\n\n---\n\n### Merged Action: `gotolocation`\n```pddl\n(:action gotolocation\n    :parameters (?agent - agent ?from - location ?to - location ?object - object)\n    :precondition (and \n        (at ?agent ?from) \n        (not (at ?agent ?to)) \n        (or (not (holding ?agent ?object)) (at ?object ?from))\n    )\n    :effect (and \n        (at ?agent ?to) \n        (not (at ?agent ?from)) \n        (when (holding ?agent ?object) (and (at ?object ?to) (not (at ?object ?from))))\n    )\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n1. **Generality:**\n   - The action is abstract and can be applied to a variety of tasks involving moving an agent, optionally moving an object, or just changing the agent's location.\n   - The `?object` parameter ensures flexibility, allowing the action to account for scenarios where an agent may be holding an object or not.\n\n2. **State Change:**\n   - The preconditions ensure that the agent is initially at the `?from` location and not already at the `?to` location.\n   - If the agent is holding an object, the preconditions also ensure that the object is initially at the `?from` location (or already being held by the agent).\n   - The effects update the state to reflect that the agent has moved to the `?to` location, and if the agent is holding an object, the object\u2019s location is also updated.\n\n3. **Simplicity:**\n   - The merged action avoids redundancy by combining the logic for moving an agent and optionally moving an object into a single action.\n   - The use of the `when` clause ensures that effects related to the object are only applied when the agent is holding it.\n\n4. **Logical Consistency:**\n   - The preconditions and effects maintain consistency across different contexts, ensuring the action is adaptable to tasks such as moving an agent, moving an object, or both.\n   - The logic avoids unnecessary complexity, focusing only on the relevant state changes.\n\n---\n\n### How This Merged Action Handles the Original Tasks:\n\n1. **Pickup Object from Desk**:\n   - The agent moves from the desk location while holding the object, updating the state to reflect the object's new location with the agent.\n\n2. **Move Agent to Desk 1**:\n   - The agent moves from one location to another without holding an object.\n\n3. **Place Object in Box**:\n   - The agent moves to the box location while holding the object, updating the state to place the object in the box.\n\n4. **Move Agent to Box Location**:\n   - The agent moves from one location to another without holding an object.\n\n---\n\n### Benefits of the Merged Action:\n- **Efficiency:** Instead of having multiple separate actions for moving an agent or moving an object, this merged action handles both scenarios in one place.\n- **Flexibility:** By using abstract parameters, the action can adapt to different contexts and tasks.\n- **Clarity:** The preconditions and effects are clearly defined, ensuring logical consistency across different scenarios.\n\nThis universal `gotolocation` action can now be used for a wide range of tasks involving movement and object interaction, simplifying the planning domain.",
    "To create a merged universal action for the tasks provided, we\u2019ll merge the two actions (`pickupobjectnoreceptacle` and `move_agent_to_desk`) into a single, generalized action. This action will retain the core logic of checking, modifying, and transforming the state while being adaptable to similar tasks involving moving agents and interacting with objects.\n\n### Merged Universal Action: `interact_with_object`\n```lisp\n(:action interact_with_object\n    :parameters (?agent - agent ?object - object ?location - location)\n    :precondition (and (at ?agent ?location) \n                       (on ?object ?location) \n                       (not (holding ?agent ?object)))\n    :effect (and (holding ?agent ?object) \n                 (not (on ?object ?location)))\n)\n```\n\n### Explanation of the Merged Action:\n1. **Generality**:\n   - The action uses abstract parameters such as `?agent` for the agent, `?object` for any object, and `?location` for any location. This makes it adaptable to a wide range of scenarios where an agent interacts with objects at specific locations.\n   - We\u2019ve avoided specifying a particular type of object (like `keychain`) or location (like `desk`) to maintain flexibility.\n\n2. **State Change**:\n   - The preconditions ensure that the agent is at the specified location, the object is present on that location, and the agent is not already holding the object.\n   - The effects describe the state change: the agent picks up the object (now `holding` it), and the object is no longer on the location.\n\n3. **Simplicity**:\n   - The merged action combines the functionality of moving to a location and interacting with an object in a single step, reducing redundancy and ensuring efficiency.\n\n4. **Logical Consistency**:\n   - The preconditions and effects are logically consistent across different tasks, ensuring correctness for tasks requiring an agent to interact with objects at specific locations.\n\n### How the Merged Action Covers Both Original Actions:\n1. **Original Action: `pickupobjectnoreceptacle`**:\n   - The merged action retains the logic of picking up an object (`holding ?agent ?object`) and removing it from the location (`not (on ?object ?location)`).\n\n2. **Original Action: Move Agent to Desk**:\n   - While the merged action does not explicitly include the movement step, it assumes that the agent is already at the location (`at ?agent ?location`) as a precondition. This is an implicit way of ensuring that the agent is in the correct place before interacting with the object.\n\nBy merging the actions in this way, we maintain the core logic of both tasks while creating a generalized and reusable action for similar scenarios.",
    "To merge the given actions into a single universal action named `putobjectinreceptacle`, we will follow the given guidelines. The universal action will generalize the parameters to allow applicability across diverse contexts, consolidate state changes to reflect the effects of both actions, and maintain logical consistency while avoiding redundancy.\n\nHere is the merged action:\n\n### Merged Action: `putobjectinreceptacle`\n```lisp\n(:action putobjectinreceptacle\n    :parameters (?agent - agent ?object - object ?receptacle - receptacle)\n    :precondition (and \n        (holding ?agent ?object)         ; The agent must be holding the object\n        (at ?agent ?receptacle)          ; The agent must be at the receptacle's location\n        (not (in ?object ?receptacle))   ; The object must not already be in the receptacle\n    )\n    :effect (and \n        (in ?object ?receptacle)         ; The object is now in the receptacle\n        (not (holding ?agent ?object))  ; The agent is no longer holding the object\n    )\n)\n```\n\n### Explanation of the Merged Action:\n1. **Generality**:\n   - The parameters have been generalized to make the action adaptable to a variety of contexts. For example, instead of specifying `?object - keychain`, we use the broader type `?object - object`, which can represent any item.\n   - The location parameter `?receptacle` is generalized to represent any container or target location (not just a \"box\").\n\n2. **State Change**:\n   - Preconditions clearly define the state before the action is executed:\n     - The agent must be holding the object.\n     - The agent must be at the location of the receptacle.\n     - The object must not already be in the receptacle.\n   - Effects clearly define the state after the action:\n     - The object is placed into the receptacle.\n     - The agent is no longer holding the object.\n   - This ensures the state transformation is consistent.\n\n3. **Core Logic**:\n   - Retains the essential preconditions and effects from the original `putobjectinreceptacle` action.\n   - Simplifies and consolidates the logic to ensure no unnecessary complexity.\n\n4. **Avoid Redundancy**:\n   - The merged action ensures there is no duplication or overlap in preconditions and effects. For example, the conditions for moving the agent to the receptacle's location are omitted since the `at` precondition already ensures the agent is in the correct location.\n\n5. **Logical Consistency**:\n   - The merged action maintains logical consistency, ensuring that the preconditions and effects align with the expected behavior of placing an object into a receptacle.\n\nThis universal `putobjectinreceptacle` action can now be used in a wide range of scenarios involving agents placing objects into containers or locations. If additional tasks, such as moving the agent to the location, are required, they can be handled by separate modular actions to keep the logic clean and reusable."
]