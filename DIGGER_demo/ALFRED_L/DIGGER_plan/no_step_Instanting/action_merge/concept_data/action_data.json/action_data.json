[
    "Here\u2019s the **merged universal action** for the `move` operation, based on the guidelines provided and the various actions shared:\n\n---\n\n### Merged Action: `move`\n\n```lisp\n(:action move\n  :parameters (?agent - agent ?from - location ?to - location)\n  :precondition (and \n                  (at ?agent ?from)\n                  (connected ?from ?to))\n  :effect (and \n            (not (at ?agent ?from))\n            (at ?agent ?to)))\n```\n\n---\n\n### Explanation of the Merged Action\n\n1. **Generality**:\n   - The parameters `?from` and `?to` are abstract, representing any valid locations.\n   - This action can be used for any movement task involving an agent transitioning between two connected locations.\n\n2. **State Change**:\n   - Preconditions ensure the agent starts at the `?from` location and that the two locations are connected.\n   - Effects update the state to reflect the agent is no longer at `?from` but now at `?to`.\n\n3. **Core Logic**:\n   - The preconditions and effects capture the essence of all the provided movement actions without unnecessary complexity.\n\n4. **Avoid Redundancy**:\n   - Actions with similar effects (e.g., moving between desks, sofas, boxes, garbage cans, etc.) have been generalized to a single `move` action.\n\n5. **Logical Consistency**:\n   - The preconditions and effects maintain logical consistency across all contexts. If the agent is already at the destination or the locations are not connected, the action cannot be executed.\n\n---\n\n### Use Cases for the Merged Action\n\nThis universal `move` action can now replace all the individual movement actions, such as:\n- `move_agent_box2_to_garbagecan`\n- `move_agent_sofa1_to_garbagecan`\n- `move_agent_to_drawer`\n- `move_agent_to_box`\n- `move_agent_to_garbage_can`\n- `move_agent_bed_to_drawer`\n- `move_agent_desk_to_sofa`\n\nBy simply supplying appropriate parameters (`?agent`, `?from`, and `?to`), this action can handle all these tasks seamlessly.\n\n---\n\nIf you have additional constraints or variations (e.g., carrying objects while moving), this action can be extended with additional parameters or preconditions/effects. Let me know if further refinements are needed!",
    "The merged action for **\"put\"** is designed to capture the essence of the various actions related to placing an object in a specific location, ensuring it is general, adaptable, and logically consistent for a variety of tasks. Here's how the universal action looks:\n\n---\n\n### Universal Action: `put`\n\n```lisp\n(:action put\n  :parameters (?agent - agent ?object - item ?destination - location)\n  :precondition (and \n                  (at ?agent ?destination) ;; Agent must be at the destination\n                  (holding ?agent ?object) ;; Agent must be holding the object\n                  (not (in ?object ?destination)) ;; Object must not already be in the destination\n                  (clear ?destination)) ;; Destination must be clear or available for placement\n  :effect (and \n           (in ?object ?destination) ;; Object is now in the destination\n           (not (holding ?agent ?object)) ;; Agent is no longer holding the object\n           (occupied ?destination)) ;; Destination is now occupied\n)\n```\n\n---\n\n### Explanation of the Merged Action\n\n1. **Parameters**:\n   - `?agent`: The entity performing the action (e.g., a person, robot, etc.).\n   - `?object`: The item being moved and placed (e.g., pen, book, cellphone).\n   - `?destination`: The location where the object is being placed (e.g., box, sofa, garbage can).\n\n2. **Preconditions**:\n   - `(at ?agent ?destination)`: Ensures the agent is present at the location where the object will be placed.\n   - `(holding ?agent ?object)`: Ensures the agent has the object in hand to place it.\n   - `(not (in ?object ?destination))`: Prevents redundant placement if the object is already at the destination.\n   - `(clear ?destination)`: Ensures the destination is available for the object (e.g., the box is empty or the sofa is not already occupied).\n\n3. **Effects**:\n   - `(in ?object ?destination)`: Updates the state to reflect that the object is now in the destination.\n   - `(not (holding ?agent ?object))`: Updates the state to reflect that the agent is no longer holding the object.\n   - `(occupied ?destination)`: Marks the destination as occupied (e.g., a box is no longer empty).\n\n---\n\n### Why It Works Across Multiple Scenarios\n\n1. **Generality**:\n   - The use of abstract parameters (`?object`, `?destination`) allows this action to be applied to various tasks, such as placing a pen in a box, a book on a sofa, or a cellphone in a garbage can.\n\n2. **State Change**:\n   - The preconditions ensure logical consistency (e.g., the agent must hold the object and be present at the destination), while the effects clearly update the state to reflect the successful placement of the object.\n\n3. **Core Logic**:\n   - The merged action retains the essential logic of all the individual actions, such as ensuring the agent is holding the object and that the destination is available.\n\n4. **Avoid Redundancy**:\n   - Similar actions like placing a pen, book, or cellphone in various locations are merged into a single action by abstracting the parameters and conditions.\n\n5. **Logical Consistency**:\n   - The action ensures that all preconditions and effects align with the logical flow of the task, avoiding conflicts or contradictions (e.g., placing an object in a location it already occupies).\n\n---\n\n### Examples of Usage\n\n#### Example 1: Place a Pen in a Box\n```lisp\n(:action put\n  :parameters (?agent - agent ?pen - pen ?box - box)\n  :precondition (and \n                  (at ?agent ?box)\n                  (holding ?agent ?pen)\n                  (not (in ?pen ?box))\n                  (clear ?box))\n  :effect (and \n           (in ?pen ?box)\n           (not (holding ?agent ?pen))\n           (occupied ?box))\n)\n```\n\n#### Example 2: Place a Book on a Sofa\n```lisp\n(:action put\n  :parameters (?agent - agent ?book - book ?sofa - sofa)\n  :precondition (and \n                  (at ?agent ?sofa)\n                  (holding ?agent ?book)\n                  (not (in ?book ?sofa))\n                  (clear ?sofa))\n  :effect (and \n           (in ?book ?sofa)\n           (not (holding ?agent ?book))\n           (occupied ?sofa))\n)\n```\n\n#### Example 3: Place a Cellphone in a Garbage Can\n```lisp\n(:action put\n  :parameters (?agent - agent ?cellphone - cellphone ?garbagecan - garbagecan)\n  :precondition (and \n                  (at ?agent ?garbagecan)\n                  (holding ?agent ?cellphone)\n                  (not (in ?cellphone ?garbagecan))\n                  (clear ?garbagecan))\n  :effect (and \n           (in ?cellphone ?garbagecan)\n           (not (holding ?agent ?cellphone))\n           (occupied ?garbagecan))\n)\n```\n\n---\n\n### Advantages of the Merged Action\n- **Simplifies Domain Definition**: Instead of defining separate actions for placing different objects in different locations, a single universal action handles all scenarios.\n- **Increases Reusability**: The action can be reused across tasks and domains by simply changing the parameters.\n- **Maintains Logical Integrity**: Preconditions and effects ensure the action behaves predictably and logically in all use cases.\n\nThis universal `put` action is efficient, logically consistent, and adaptable across a wide range of object-placement tasks! Let me know if you'd like further refinements or additional examples. \ud83d\ude0a",
    "### Merged Action: `pick`\n\n```lisp\n(:action pick ; Unified action for picking up an object from a location\n    :parameters (?agent - agent ?item - item ?location - location)\n    :precondition (and\n                    (at ?agent ?location)\n                    (or (in ?item ?location) (on ?item ?location) (at ?item ?location))\n                    (not (holding ?agent ?item)))\n    :effect (and\n              (holding ?agent ?item)\n              (not (in ?item ?location))\n              (not (on ?item ?location))\n              (not (at ?item ?location)))\n)\n```\n\n---\n\n### Explanation of the Merged Action\n\n#### **Generality**\n- The merged action `pick` is designed to handle a variety of object-picking scenarios by using abstract parameters (`?item`, `?location`, `?agent`).\n- The precondition `(or (in ?item ?location) (on ?item ?location) (at ?item ?location))` ensures that it covers all possible object-location relationships (e.g., item in drawer, item on desk, item at location).\n\n#### **State Change**\n- Preconditions ensure that the agent is at the correct location and the object is available to be picked up.\n- Effects transform the state to reflect that the agent is now holding the item, and the item is no longer at its original location (whether it was `in`, `on`, or `at` the location).\n\n#### **Core Logic**\n- Retains the essential preconditions and effects for picking up an object, abstracting away specific object types (e.g., cellphone, watch, keychain) or location types (e.g., drawer, desk, sofa).\n\n#### **Avoid Redundancy**\n- By combining all item-picking actions into a single `pick` action, redundancies in similar effects and preconditions are eliminated.\n\n#### **Logical Consistency**\n- The merged action is consistent across different contexts, maintaining clear and reasonable preconditions (agent must be at the location, item must be accessible) and effects (agent holds the item, item is no longer at the location).\n\n---\n\n### Application of the Merged Action in Different Scenarios\n\n1. **Picking up a cellphone from a drawer:**\n   ```lisp\n   (:action pick\n       :parameters (?agent - agent ?cellphone - cellphone ?drawer - drawer)\n       :precondition (and\n                       (at ?agent ?drawer)\n                       (in ?cellphone ?drawer)\n                       (not (holding ?agent ?cellphone)))\n       :effect (and\n                 (holding ?agent ?cellphone)\n                 (not (in ?cellphone ?drawer)))\n   )\n   ```\n\n2. **Picking up a laptop from a sofa:**\n   ```lisp\n   (:action pick\n       :parameters (?agent - agent ?laptop - laptop ?sofa - sofa)\n       :precondition (and\n                       (at ?agent ?sofa)\n                       (on ?laptop ?sofa)\n                       (not (holding ?agent ?laptop)))\n       :effect (and\n                 (holding ?agent ?laptop)\n                 (not (on ?laptop ?sofa)))\n   )\n   ```\n\n3. **Picking up a keychain from a desk:**\n   ```lisp\n   (:action pick\n       :parameters (?agent - agent ?keychain - keychain ?desk - desk)\n       :precondition (and\n                       (at ?agent ?desk)\n                       (on ?keychain ?desk)\n                       (not (holding ?agent ?keychain)))\n       :effect (and\n                 (holding ?agent ?keychain)\n                 (not (on ?keychain ?desk)))\n   )\n   ```\n\n---\n\n### Benefits of the Merged Action\n\n1. **Reusability:**\n   - The `pick` action can be reused across a wide range of tasks, reducing the need for defining multiple similar actions.\n\n2. **Simplicity:**\n   - Combines the logic of multiple specific actions into a single, streamlined action.\n\n3. **Efficiency:**\n   - Fewer actions in the PDDL domain file lead to improved readability and potentially faster planning.\n\n4. **Consistency:**\n   - Ensures uniformity in how picking actions are defined and executed across different scenarios.\n\n---\n\nLet me know if you need further assistance or additional merged actions!",
    "### Merged Action: `prevent`\n\nThe merged action combines the logic of preventing an object from being placed in a specific location (e.g., a box) while maintaining adaptability to various tasks. Here's the resulting universal `prevent` action:\n\n```PDDL\n(:action prevent\n    ; Prevent an object from being placed in a specified location\n    :parameters (?agent - agent ?object - item ?location - location)\n    :precondition (and\n                    (holding ?agent ?object)\n                    (is_location ?location))\n    :effect (not (at ?object ?location)))\n```\n\n---\n\n### Explanation of the Merged Action\n\n1. **Generality**:\n   - The merged action uses abstract parameters (`?agent`, `?object`, `?location`) to allow flexibility and adaptability for different scenarios.\n   - The term `is_location` replaces specific predicates like `is_box` to generalize the action for any type of location.\n\n2. **State Change**:\n   - The precondition ensures the agent is already holding the object and that the location is valid.\n   - The effect explicitly removes the possibility of the object being placed at the specified location (`not (at ?object ?location)`).\n\n3. **Simplicity**:\n   - Redundant logic and overly specific predicates (e.g., `is_box`) have been removed.\n   - The action is streamlined to focus on the core task of preventing an object from being placed in a location.\n\n4. **Logical Consistency**:\n   - Preconditions remain reasonable: the agent must be holding the object, and the target location must exist.\n   - The effect is clear and aligns with the task's objective of ensuring the object is not at the specified location.\n\n---\n\n### Combined Actions After the Merger\n\nHere are the actions after merging:\n\n#### Action: `check`\n```PDDL\n(:action check\n    ; Check a resource and update task status\n    :parameters (?npc - person ?item - object)\n    :precondition (and (available ?npc) (not (checked ?npc ?item)))\n    :effect (checked ?npc ?item))\n```\n\n#### Action: `prevent`\n```PDDL\n(:action prevent\n    ; Prevent an object from being placed in a specified location\n    :parameters (?agent - agent ?object - item ?location - location)\n    :precondition (and\n                    (holding ?agent ?object)\n                    (is_location ?location))\n    :effect (not (at ?object ?location)))\n```\n\n---\n\n### Applications\n\n- The `check` action is versatile for tasks involving checking the status of resources or updating statuses.\n- The `prevent` action can be applied in scenarios requiring constraints to be enforced, such as ensuring an object is not placed in a prohibited area (e.g., a box, a room, or a restricted zone).\n\nLet me know if you need further adjustments or additional merged actions!",
    "Here is the merged action after combining the given actions while adhering to your guidelines of generality, state change, simplicity, and logical consistency:\n\n---\n\n### Final Merged Action: `avoid`\n\n```pddl\n(:action avoid ; Avoid placing an object in a restricted location\n :parameters (?agent - agent ?item - object ?restricted_location - location)\n :precondition (and\n                 (holding ?agent ?item)\n                 (at ?agent ?restricted_location))\n :effect (and\n           (not (in ?item ?restricted_location))))\n```\n\n---\n\n### Explanation of the Merged Action\n\n#### **Generality**\n- The merged action is generalized to handle any agent (`?agent`), any object (`?item`), and any restricted location (`?restricted_location`).\n- It is adaptable to various tasks by abstracting specific entities like books, boxes, and players into generic placeholders.\n\n#### **State Change**\n- Clearly describes the state change: If an agent is holding an object and is at a restricted location, the action ensures the object will **not** be placed in that location.\n- The action captures the intent of avoiding placing a specific object in a restricted area, transforming the state to ensure the object remains unplaced at that location.\n\n#### **Simplicity**\n- Redundant details from the original actions (e.g., specific references to books or boxes) are removed, keeping the action concise and efficient.\n- The core logic is retained without unnecessary complexity.\n\n#### **Logical Consistency**\n- Preconditions ensure the action only applies when the agent is holding the object and is at the restricted location.\n- Effects logically enforce that the object will not end up in the restricted location, aligning with the intended constraints.\n\n#### **Use Case**\nThis merged action can be applied to a variety of tasks involving constraints on placing objects in specific locations. For example:\n- Avoid placing a book in a box.\n- Prevent a player from putting an object in a restricted area in a game.\n- Enforce rules in resource management or logistics systems where certain objects cannot be placed in certain locations.\n\n---\n\nThis merged action aligns with the guidelines you provided and ensures adaptability, clarity, and logical consistency across tasks.",
    "After merging the provided actions into a single universal `pickup` action, we aim to maintain generality, simplicity, and logical consistency. Here's the merged action:\n\n---\n\n### Merged Action: Pickup\n```lisp\n(:action pickup\n    :parameters (?agent - agent ?item - object ?container - container)\n    :precondition (and\n                    (at ?agent ?container)\n                    (in ?item ?container)\n                    (free_hand ?agent))\n    :effect (and\n              (holding ?agent ?item)\n              (not (in ?item ?container)))\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n1. **Generality**:\n   - The merged `pickup` action is abstracted to work with any `?item` in any `?container` (e.g., garbagecans, boxes, drawers, etc.).\n   - The action is not specific to a particular type of object (e.g., pens, books) or container, making it adaptable to a variety of tasks.\n\n2. **State Change**:\n   - Preconditions ensure that the agent is at the location of the container (`at ?agent ?container`), the item is inside the container (`in ?item ?container`), and the agent has a free hand to pick up the item (`free_hand ?agent`).\n   - The effects update the state to reflect that the agent is now holding the item (`holding ?agent ?item`), and the item is no longer in the container (`not (in ?item ?container)`).\n\n3. **Core Logic**:\n   - The core logic of the preconditions and effects from the original actions is preserved. All the original actions involve picking up an item from a container, and this is reflected in the merged action.\n\n4. **Avoid Redundancy**:\n   - Redundant parameters and predicates specific to certain objects or containers (e.g., `in_drawer` or `in_box`) have been generalized to `in ?item ?container`.\n   - This ensures that the action is simple and efficient while retaining the core functionality.\n\n5. **Logical Consistency**:\n   - The merged action ensures that logical consistency is maintained across different tasks. For example, the `free_hand` predicate ensures the agent can only pick up an item if their hands are free, preventing conflicts in concurrent actions.\n\n---\n\nThis universal `pickup` action can be used in various domains involving agents picking up items from different types of containers, such as garbage cans, boxes, or drawers. It is abstract enough to handle diverse scenarios while retaining the core logic and state transformation required for such tasks."
]