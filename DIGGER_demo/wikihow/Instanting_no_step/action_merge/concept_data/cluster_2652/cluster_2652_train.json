[
    "After merging the given actions into a single universal `check` action, the result should satisfy the principles of **generality**, **state change**, **simplicity**, and **logical consistency**. Here's the merged action:\n\n```lisp\n(:action check ; General action to check and update knowledge or status of an entity\n  :parameters (?agent - entity ?target - entity ?attribute - attribute)\n  :precondition (and\n                 (available ?agent) ; The agent must be available\n                 (exists (?attribute-value - attribute-value)\n                         (and (has ?target ?attribute-value ?attribute) ; Target must have the attribute being checked\n                              (not (checked ?agent ?target ?attribute-value)))) ; The attribute must not have been checked by the agent\n  )\n  :effect (and \n           (checked ?agent ?target ?attribute-value) ; Mark the attribute as checked\n           (knows ?agent ?attribute ?attribute-value)) ; Update the agent's knowledge or awareness of the attribute value\n)\n```\n\n### Explanation of the Merged Action\n\n1. **Generality**:\n   - The `check` action is abstract and applies to a broad range of scenarios where an agent (e.g., a player, NPC, or system) interacts with a target (e.g., a location, object, or another entity) to verify or observe an attribute or property.\n   - The use of `?attribute` and `?attribute-value` allows the action to handle various specific cases, such as checking the compost temperature, observing compost consistency, or verifying the availability of a facility.\n\n2. **State Change**:\n   - The action marks the `attribute-value` of the `target` as `checked` by the `agent`.\n   - It also updates the agent's knowledge (`knows ?agent ?attribute ?attribute-value`), ensuring the state is progressively transformed toward the goal (e.g., knowing the compost is cured, the location has commercial composting, etc.).\n\n3. **Simplicity**:\n   - Redundancies from individual actions (e.g., `check-commercial-composting`, `check-compost-temperature`, `examine-compost`, etc.) are eliminated by using generalized parameters and conditions.\n   - The core logic of each individual action is preserved but abstracted to apply to multiple contexts.\n\n4. **Logical Consistency**:\n   - Preconditions ensure that the agent can only check a target that has the relevant attribute (`has ?target ?attribute-value ?attribute`) and that the attribute has not already been checked.\n   - Effects update the agent's awareness while maintaining consistency with the state of the target.\n\n---\n\n### How the Merged Action Covers the Given Examples\n\n1. **Check Commercial Composting**:\n   - `?agent = ?p (player)`, `?target = ?area (location)`, `?attribute = commercial_composting_available`\n   - Preconditions: `(and (available ?p) (has ?area commercial_composting_available))`\n   - Effects: `(checked ?p ?area commercial_composting_available) (knows ?p commercial_composting_available)`\n\n2. **Check Compost Temperature**:\n   - `?agent = ?observer`, `?target = ?t (tumbler)`, `?attribute = temperature`\n   - Preconditions: `(and (available ?observer) (has ?t temperature))`\n   - Effects: `(checked ?observer ?t temperature) (knows ?observer temperature)`\n\n3. **Examine Compost**:\n   - `?agent = ?observer`, `?target = ?bin (bin)`, `?attribute = cured`\n   - Preconditions: `(and (available ?observer) (has ?bin cured) (wet ?bin) (rolled ?bin))`\n   - Effects: `(checked ?observer ?bin cured) (knows ?observer cured)`\n\n4. **Monitor Temperature**:\n   - `?agent = ?observer`, `?target = ?t (tumbler)`, `?attribute = temperature`\n   - Preconditions: `(and (available ?observer) (has ?t temperature))`\n   - Effects: `(checked ?observer ?t temperature) (knows ?observer temperature)`\n\n5. **Observe Color and Consistency**:\n   - `?agent = ?observer`, `?target = ?c (compost)`, `?attribute = color`\n   - Preconditions: `(and (available ?observer) (has ?c color))`\n   - Effects: `(checked ?observer ?c color) (knows ?observer color)`\n\n---\n\n### Advantages of the Merged Action\n- **Flexibility**: The action can be reused in diverse scenarios by simply substituting parameters.\n- **Efficiency**: Redundant logic is removed, reducing complexity while maintaining clarity.\n- **Scalability**: New tasks requiring checks can be incorporated without creating additional actions. For example, checking moisture levels, nutrient content, or any other attribute of an entity can be handled by this single `check` action.\n\nThis merged `check` action is an adaptable template for a wide variety of tasks involving verification, observation, or inspection.",
    "Here is the **merged action** for `add`, combining all the provided actions into a single, generalized and universal PDDL action while maintaining logical consistency, avoiding redundancy, and ensuring adaptability to various contexts:\n\n---\n\n### Merged Universal Action: `add`\n```lisp\n(:action add\n    :parameters (?actor - agent ?item - material ?container - container ?location - location ?condition - predicate)\n    :precondition (and\n                    (at ?actor ?location)\n                    (inventory ?actor ?item)\n                    (ready_for_use ?container)\n                    (not (in ?item ?container))\n                    (valid_condition ?condition ?container))\n    :effect (and\n              (in ?item ?container)\n              (not (inventory ?actor ?item))\n              (updated ?container ?condition))\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n\n1. **Generality**:\n   - The `add` action is designed to cover all scenarios where an agent (e.g., a player or NPC) adds an item (material) to a container (e.g., compost bin, composter, barrel) at a specific location.\n   - The `?condition` parameter allows flexibility in defining custom conditions for the action to occur (e.g., `ready_for_composting`, `empty`, `enclosed`).\n\n2. **Abstract Parameters**:\n   - `?actor`: Represents the agent (player or NPC) performing the action.\n   - `?item`: Represents the material/item being added (e.g., fish remains, seaweed, manure).\n   - `?container`: Represents the target container (e.g., compost bin, composter, tumbler, barrel).\n   - `?location`: Represents the location where the action takes place.\n   - `?condition`: Represents any specific condition that must hold for the container (e.g., `ready_for_composting`, `enclosed`, `full`).\n\n3. **Preconditions**:\n   - `(at ?actor ?location)`: The actor must be present at the location.\n   - `(inventory ?actor ?item)`: The actor must have the item in their inventory.\n   - `(ready_for_use ?container)`: The container must be ready for the action.\n   - `(not (in ?item ?container))`: The item should not already be in the container.\n   - `(valid_condition ?condition ?container)`: The condition (e.g., `enclosed`, `empty`) must be valid for the container.\n\n4. **Effects**:\n   - `(in ?item ?container)`: The item is added to the container.\n   - `(not (inventory ?actor ?item))`: The item is removed from the actor's inventory.\n   - `(updated ?container ?condition)`: The container's state is updated based on the condition.\n\n---\n\n### How This Merged Action Covers All Provided Actions:\n\n1. **`add_fish_remains_to_compost`**:\n   - `?item = fish_remains`\n   - `?container = compost`\n   - `?condition = ready_for_composting`\n\n2. **`add_fish_remains_to_enclosed_composter`**:\n   - Adds the `valid_condition` check for `enclosed` in the generalized preconditions.\n\n3. **`add_manure_and_organics`**:\n   - Supports multiple materials (`manure`, `leaves`, `grass`, etc.) through repeated calls to `add` for each material.\n\n4. **`add_water`**:\n   - `?item = water`\n   - `?container = bin`\n   - `?condition = dry`\n\n5. **`add_garden_lime`**:\n   - `?item = lime`\n   - `?container = tumbler`\n   - `?condition = smelly`\n\n6. **`add_nitrogen_layer`**:\n   - `?item = nitrogen_material`\n   - `?container = container`\n   - `?condition = nitrogen_rich`\n\n7. **`alternate_layers`**:\n   - Handles alternating carbon and nitrogen layers by calling `add` separately for each material with the appropriate conditions.\n\n8. **`mix_seaweed_compost`**:\n   - `?item = seaweed`\n   - `?container = compost`\n   - Adds the `mixed` effect as part of the container update.\n\n---\n\n### Advantages of the Merged Action:\n\n1. **Simplicity and Efficiency**:\n   - The single `add` action eliminates redundancy by consolidating similar actions into one universal structure.\n\n2. **Adaptability**:\n   - By using abstract parameters (`?item`, `?container`, `?condition`), the action can be adapted to a wide variety of use cases, from composting to inventory management.\n\n3. **Scalability**:\n   - The preconditions and effects are flexible enough to handle additional conditions or extensions (e.g., adding new materials or container types).\n\n4. **Logical Consistency**:\n   - The action ensures the logical flow of states, from the preconditions to the effects, making it suitable for diverse contexts.\n\n---\n\nThis merged action provides a clean, efficient, and adaptable framework for handling a wide range of \"add\" operations in PDDL.",
    "After merging the given actions into the universal action `select`, here is the result:\n\n```lisp\n(:action select ; Select and assign an entity or resource for a specific purpose\n  :parameters (?actor - agent ?entity - object ?context - context)\n  :precondition (and\n                  (available ?actor)\n                  (unselected ?entity)\n                  (valid_context ?entity ?context))\n  :effect (and\n           (selected ?entity)\n           (assigned ?actor ?entity ?context)\n           (not (unselected ?entity)))\n)\n```\n\n### Explanation of the Merged `select` Action:\n\n1. **Generality**:\n   - The merged action `select` is abstract and adaptable to a wide variety of tasks. \n   - It uses generic parameters like `?actor` (representing the agent performing the action), `?entity` (the object being selected), and `?context` (the context or purpose for selection), allowing it to apply to multiple scenarios such as selecting an area, assigning a resource, or determining the purpose of an object.\n\n2. **State Change**:\n   - The precondition `(unselected ?entity)` ensures the action applies only to entities that are not yet selected.\n   - The effect `(selected ?entity)` changes the state of the entity to \"selected.\"\n   - Additional effects such as `(assigned ?actor ?entity ?context)` update the task status to reflect the actor's involvement and the context in which the entity is being used.\n\n3. **Simplicity**:\n   - The merged action avoids redundancy by combining similar tasks (e.g., selecting an area, choosing a purpose for an item, or returning a container to its location) into a single abstract action.\n   - Unnecessary complexity is avoided, as the core logic of preconditions and effects is preserved while abstracting the details.\n\n4. **Logical Consistency**:\n   - Preconditions like `(available ?actor)` and `(valid_context ?entity ?context)` ensure the action is only applicable in reasonable circumstances.\n   - Effects such as `(not (unselected ?entity))` maintain consistent state transitions.\n\n### Key Merged Components:\n- **From `select_suitable_area`**:\n  - The idea of selecting an area and transitioning its state from `unselected` to `selected` is preserved.\n- **From `choose_usage`**:\n  - The concept of assigning a purpose (`context`) to an entity is incorporated via the parameter `?context` and the effect `(assigned ?actor ?entity ?context)`.\n- **From `return_container_to_kitchen`**:\n  - The state transition (e.g., moving an object from one state to another) is generalized through the `context` parameter.\n\nThis universal `select` action can now handle a variety of tasks, including selecting areas, assigning purposes to objects, and transitioning states of resources, all while remaining logically consistent and efficient.",
    "After merging the provided actions under the objective \"create,\" the resulting universal action would look like this:\n\n```lisp\n(:action create ; Create or prepare a resource by combining components or transitioning its state\n  :parameters (?actor - entity ?resource - object ?location - location ?component1 - object ?component2 - object ?component3 - object)\n  :precondition (and\n                  (at ?actor ?location)\n                  (or (and (inventory ?actor ?component1) (inventory ?actor ?component2) (inventory ?actor ?component3))\n                      (and (selected ?location) (empty ?resource))\n                      (and (inventory ?actor ?resource) (clean ?resource) (intended_usage ?resource liquid_fertilizer))\n                      (and (inventory ?actor ?component1) (at ?component2 ?location) (bed_of_worms ?location))\n                      (and (in_cabinet ?resource) (empty ?resource)))\n                 )\n  :effect (and\n            (or (and (constructed ?resource)\n                     (in_area ?resource ?location)\n                     (not (empty ?resource)))\n                (and (in ?component1 ?resource)\n                     (in ?component2 ?resource)\n                     (in ?component3 ?resource)\n                     (not (inventory ?actor ?component1))\n                     (not (inventory ?actor ?component2))\n                     (not (inventory ?actor ?component3)))\n                (and (in ?resource ?location)\n                     (liquid_fertilizer ?resource))\n                (and (worm_castings ?resource)\n                     (not (inventory ?actor ?component1)))\n                (and (on_countertop ?resource)\n                     (ready_for_use ?resource)\n                     (not (in_cabinet ?resource)))))\n)\n```\n\n### Explanation of the Merged Action:\n1. **Generality:**\n   - Abstract parameters (`?actor`, `?resource`, `?location`, `?component1`, `?component2`, `?component3`) are used to make the action adaptable to various tasks, such as building, combining, transforming, and preparing resources.\n   - Covers all provided tasks, such as building compost bins, creating liquid fertilizer, making worm castings, preparing containers, and adding layers to a container.\n\n2. **State Change:**\n   - The preconditions and effects are designed to reflect the state changes for all the given actions. For example, transitioning from `empty` to `constructed`, moving items into a container, or changing the state of a container from `in_cabinet` to `on_countertop`.\n\n3. **Simplicity:**\n   - Redundant actions like moving multiple items into a container (`in ?component1 ?resource`, etc.) are combined into a single universal logic.\n   - The action avoids duplicating logic for similar tasks, such as combining items or transitioning resource states.\n\n4. **Logical Consistency:**\n   - Maintains clear preconditions and effects for different contexts without contradictions.\n   - Handles multiple conditions (e.g., a resource being empty, components being in inventory, or specific locations being prepared) while ensuring logical consistency.\n\n### How the Merged Action Covers Original Actions:\n- **Building Compost Bins:** `(selected ?location)` and `(empty ?resource)` lead to `(constructed ?resource)` and `(in_area ?resource ?location)`.\n- **Creating Liquid Fertilizer:** `(inventory ?actor ?resource)` and `(clean ?resource)` lead to `(in ?resource ?location)` and `(liquid_fertilizer ?resource)`.\n- **Making Worm Castings:** `(inventory ?actor ?component1)` and `(at ?component2 ?location)` lead to `(worm_castings ?resource)` and removing `?component1` from the inventory.\n- **Layering Materials:** `(inventory ?actor ?component1)` for multiple components leads to `in` effects for a container and removes the components from the inventory.\n- **Preparing Kitchen Compost Container:** `(in_cabinet ?resource)` and `(empty ?resource)` lead to `(on_countertop ?resource)` and `(ready_for_use ?resource)`.\n\nThis unified \"create\" action is general, efficient, and logically consistent across the tasks provided.",
    "Here's the merged action for the \"roll\" task after combining the provided actions. The goal is to generalize the concept of manipulating an object (e.g., rolling, tumbling, or mixing) to achieve a transformed state, while adhering to the given guidelines:\n\n---\n\n### Merged Action: `roll`\n\n```lisp\n(:action roll ; Manipulate an object to transform or optimize its state\n    :parameters (?obj - object)\n    :precondition (and \n                    (processable ?obj) ; The object is suitable for the operation\n                    (not (processed ?obj))) ; The object hasn't been processed yet\n    :effect (and \n              (processed ?obj) ; The object has been processed\n              (optimized ?obj)) ; The object state has been improved/optimized\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n\n1. **Generality**:\n   - The action `roll` is generalized to apply to any object (`?obj`), not just bins or tumblers. This increases applicability to various tasks, such as rolling, tumbling, or mixing objects.\n   - Abstract parameters (`?obj - object`) ensure that the action is not limited to specific object types (e.g., bins, tumblers).\n\n2. **State Change**:\n   - The precondition `(not (processed ?obj))` ensures the action can only be performed on objects that haven\u2019t yet been processed.\n   - The effect `(processed ?obj)` indicates the object has been processed.\n   - The additional effect `(optimized ?obj)` reflects the intended outcome of the action, such as aerating, mixing, or improving the object's state.\n\n3. **Simplicity**:\n   - Redundant or overly specific elements were removed (e.g., `full`, `moist`, or `not (overfilled)`), as these can be abstracted into the `processable` predicate.\n   - The merged action is clean and adaptable to multiple scenarios.\n\n4. **Logical Consistency**:\n   - Preconditions and effects are consistent across different interpretations of the action. For example:\n     - Rolling a manure pile (`rolled` and `aerated`) aligns with processing and optimizing.\n     - Tumbling a composter (`mixed`) also aligns with processing and optimizing.\n\n---\n\n### Example Instantiations of the Merged Action:\n\n1. **Rolling a Manure Pile**:\n   ```lisp\n   (:action roll_manure_pile\n       :parameters (?pile - bin)\n       :precondition (and \n                       (full ?pile)\n                       (processable ?pile)\n                       (not (processed ?pile)))\n       :effect (and \n                 (processed ?pile)\n                 (optimized ?pile)))\n   ```\n\n2. **Tumbling a Composter**:\n   ```lisp\n   (:action tumble_composter\n       :parameters (?composter - tumbler)\n       :precondition (and \n                       (in ?composter)\n                       (moist ?composter)\n                       (processable ?composter)\n                       (not (processed ?composter)))\n       :effect (and \n                 (processed ?composter)\n                 (optimized ?composter)))\n   ```\n\n3. **Adding Garden Lime**:\n   ```lisp\n   (:action add_garden_lime\n       :parameters (?compost - compost)\n       :precondition (and \n                       (processable ?compost)\n                       (not (processed ?compost)))\n       :effect (and \n                 (processed ?compost)\n                 (optimized ?compost)))\n   ```\n\nBy using this generalized `roll` action, we can represent a broad range of tasks that involve transforming or improving the state of an object, while maintaining logical consistency and simplicity.",
    "Here is the merged action for the \"place\" task based on the given actions. This universal action is designed to accommodate general placement, resource usage, and state transformation tasks while adhering to the guidelines:\n\n```lisp\n(:action place ; Place an item, resource, or container in a specific location or state\n  :parameters (?actor - agent ?item - object ?target - location ?condition - condition_type)\n  :precondition (and \n      (at ?actor ?target) ; The actor must be at the target location\n      (inventory ?actor ?item) ; The actor must have the item in their inventory\n      (valid_condition ?target ?condition) ; The target location must satisfy a valid condition\n  )\n  :effect (and \n      (placed ?item ?target) ; The item is now placed at the target location\n      (not (inventory ?actor ?item)) ; The item is no longer in the actor's inventory\n      (updated_condition ?target ?condition) ; The target location's state is updated to reflect the condition\n  )\n)\n```\n\n### Explanation of the Universal Action\n1. **Generality**:\n   - The `?actor` parameter represents the person or agent performing the action.\n   - The `?item` parameter generalizes any object being placed, such as seaweed, a tumbler, or a container.\n   - The `?target` parameter represents the location or destination for the item.\n   - The `?condition` parameter represents any relevant condition (e.g., suitability, cleanliness, or weather) that needs to be satisfied at the target location.\n\n2. **State Change**:\n   - The action updates the state by marking the `?item` as placed at `?target` and removes the item from the actor's inventory.\n   - It also updates the condition at the target location to reflect the successful placement.\n\n3. **Simplicity**:\n   - This merged action simplifies the preconditions and effects by combining similar effects like \"clean\", \"wet\", or \"placed\" into a more abstract state update.\n\n4. **Logical Consistency**:\n   - The preconditions ensure that the actor is in the right location, has the item in their inventory, and that the target location satisfies the required condition.\n   - The effects are consistent and reflect the logical result of the action (e.g., the item is placed, and the state of the target location is updated).\n\n---\n\n### How It Covers the Original Actions\n1. **`wash_seaweed`**:\n   - The `?item` is `?seaweed`, the `?target` is `?home`, and the precondition includes `has_water ?home`, which maps to a `valid_condition`.\n\n2. **`place-tumbler`**:\n   - The `?item` is `?t`, the `?target` is `?l`, and the precondition includes `suitable-location ?l`, which maps to a `valid_condition`.\n\n3. **`place_bin_in_sun`**:\n   - The `?item` is `?container`, the `?target` is `?location`, and the precondition includes `sunny ?location`, which maps to a `valid_condition`.\n\n4. **`spray_water`**:\n   - The `?item` is `?water`, the `?target` is `?container`, and the precondition includes `not (wet ?container)`, which maps to a `valid_condition`.\n\n---\n\nThis merged action can be reused for a variety of placement-related tasks while remaining abstract, logical, and efficient. It ensures the same core logic applies across different contexts without unnecessary complexity.",
    "Here\u2019s how the merged action for the **limit** tasks would look based on the provided examples, following the given guidelines:\n\n---\n\n### **Merged Action: limit**\n```lisp\n(:action limit ; Limit a resource or entity to ensure proper constraints\n    :parameters (?entity - object ?condition - state)\n    :precondition (and (applicable ?entity) (violates ?entity ?condition))\n    :effect (and (not (violates ?entity ?condition)) (limited ?entity ?condition))\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n1. **Generality**:\n   - The action is abstract and adaptable, referring to a generic `?entity` (which can be any object) and a `?condition` (indicating the state that needs to be limited). This ensures it\u2019s not tied to a specific domain or task.\n   - For example:\n     - A tumbler\u2019s capacity (`?entity - tumbler`, `?condition - overfilled`).\n     - Another resource\u2019s constraints can also fit into this action structure.\n\n2. **State Change**:\n   - Preconditions:\n     - `(applicable ?entity)` ensures the `?entity` is relevant for the action.\n     - `(violates ?entity ?condition)` ensures the `?entity` is currently in a state where it violates the specified `?condition`.\n   - Effects:\n     - `(not (violates ?entity ?condition))` removes the violation of the condition.\n     - `(limited ?entity ?condition)` ensures the `?entity` is now constrained or limited according to the condition.\n\n3. **Simplicity**:\n   - The action is concise and avoids redundancy by capturing the core logic of checking for violations and applying limits in a single, reusable action.\n\n4. **Logical Consistency**:\n   - Preconditions and effects are logically aligned to represent the action of imposing limits on an entity based on a condition.\n\n---\n\n### Example Applications:\n1. **For Tumbler Capacity**:\n   ```lisp\n   (:action limit ; Limit tumbler capacity\n       :parameters (?t - tumbler ?condition - state)\n       :precondition (and (in ?t) (violates ?t overfilled))\n       :effect (and (not (violates ?t overfilled)) (limited ?t overfilled))\n   )\n   ```\n\n2. **For Other Tasks**:\n   - **Limiting resource usage**:\n     ```lisp\n     (:action limit ; Limit resource usage\n         :parameters (?resource - resource ?condition - state)\n         :precondition (and (in_use ?resource) (violates ?resource overused))\n         :effect (and (not (violates ?resource overused)) (limited ?resource overused))\n     )\n     ```\n\n3. **For Harvesting Rich Compost**:\n   If the domain is about ensuring a resource (like compost) is in a proper state, the same action could be adapted:\n   ```lisp\n   (:action limit ; Limit compost quality\n       :parameters (?compost - resource ?condition - state)\n       :precondition (and (quality_check ?compost) (violates ?compost poor_quality))\n       :effect (and (not (violates ?compost poor_quality)) (limited ?compost high_quality))\n   )\n   ```\n\n---\n\nBy using abstract parameters (`?entity`, `?condition`), this merged action achieves broad applicability, maintaining logical consistency and simplicity while ensuring clear state changes.",
    "Here is how we can merge the given actions into a single universal `moisten` action, following the guidelines of generality, state change, simplicity, and logical consistency. The merged action will be adaptable to a variety of tasks involving moistening or ensuring resource readiness while maintaining consistency in preconditions and effects.\n\n---\n\n### Merged Action: `moisten`\n```lisp\n(:action moisten\n    :parameters (?entity - object ?resource - resource)\n    :precondition (and (needs-moisture ?entity) (available ?resource))\n    :effect (and (moist ?entity) (not (needs-moisture ?entity)))\n)\n```\n\n### Explanation:\n1. **Generality**: The action uses abstract parameters:\n   - `?entity` can represent any object that needs to be moistened or hydrated (e.g., compost, soil, or another resource).\n   - `?resource` represents the resource used to perform the action (e.g., water, liquid, or moisture source).\n   \n   This makes the action flexible and adaptable to a variety of tasks requiring moistening or hydration.\n\n2. **State Change**:\n   - The precondition `(needs-moisture ?entity)` ensures that the entity requires moistening before the action is performed.\n   - `(available ?resource)` ensures the resource required to moisten the entity is available.\n   - The effect `(moist ?entity)` indicates the entity becomes moist, while `(not (needs-moisture ?entity))` ensures the entity no longer needs moisture.\n\n3. **Core Logic**:\n   - The precondition and effect structure retains the core logic of the original actions, ensuring a clear and gradual state transformation.\n   - The logic is abstracted to work across different contexts without unnecessary complexity.\n\n4. **Simplicity and Avoiding Redundancy**:\n   - The merged action simplifies the representation by removing task-specific details (e.g., compost-specific or water-specific terms) while retaining the functionality.\n   - Redundant or overly specific elements from the original actions are eliminated.\n\n5. **Logical Consistency**:\n   - The preconditions and effects are consistent and reasonable in different contexts.\n   - For example, if the entity is already moist, the action will not be executed because `(needs-moisture ?entity)` would not hold.\n\n---\n\n### Example Tasks Adaptable to the Merged Action:\n- Moistening compost with water: `?entity` = compost, `?resource` = water.\n- Hydrating a plant with liquid: `?entity` = plant, `?resource` = liquid.\n- Rehydrating dried soil with a moisture source: `?entity` = soil, `?resource` = moisture-source.\n\nThis approach ensures the action is universal, adaptable, and logically consistent across a wide range of tasks.",
    "Here is the **merged action** for the \"use\" task that combines and generalizes the provided PDDL actions while adhering to the given guidelines:\n\n---\n\n### **Merged Action: use**\n```pddl\n(:action use\n    :parameters (?agent - entity ?tool - resource ?target - object)\n    :precondition (and \n        (ready ?tool) \n        (exists (?need - attribute) (needs ?target ?need))\n        (not (used ?tool ?target))\n    )\n    :effect (and \n        (fulfilled ?target ?need) \n        (used ?tool ?target))\n)\n```\n\n---\n\n### **Explanation of the Merged Action:**\n\n1. **Generality**:\n   - The `use` action is designed to be abstract and adaptable to different tasks.\n   - `?agent` represents the entity performing the action (e.g., a person, robot, etc.).\n   - `?tool` represents the resource being used (e.g., compost, secondary bin, or any other usable resource).\n   - `?target` represents the object or entity the tool is applied to (e.g., a plant, bin, or any other target).\n\n2. **Preconditions**:\n   - `(ready ?tool)`: Ensures that the resource (e.g., compost) is in a state ready for use.\n   - `(exists (?need - attribute) (needs ?target ?need))`: Ensures the target has a specific unmet need that the tool can fulfill.\n   - `(not (used ?tool ?target))`: Ensures the tool hasn't already been used on the target to avoid redundancy.\n\n3. **Effects**:\n   - `(fulfilled ?target ?need)`: Marks the target's need as fulfilled, indicating a successful state change.\n   - `(used ?tool ?target)`: Marks the tool as used, preventing repeated applications.\n\n---\n\n### **How the Merged Action Captures the Original Actions**:\n\n#### **Action: use-compost**\n- `?agent` would represent the person or entity using the compost.\n- `?tool` would represent the compost.\n- `?target` would represent the plant.\n- Preconditions of `use-compost` are generalized as `(ready ?tool)` and `(exists (?need - attribute) (needs ?target ?need))`.\n- Effects of `use-compost` are generalized as `(fulfilled ?target ?need)` and `(used ?tool ?target)`.\n\n#### **Action: use_secondary_compost_bin**\n- `?agent` would represent the person or system managing the bins.\n- `?tool` would represent the secondary compost bin.\n- `?target` would represent the primary bin.\n- Preconditions of `use_secondary_compost_bin` are generalized as `(ready ?tool)` (e.g., `secondary_bin_available`) and `(exists (?need - attribute) (needs ?target ?need))` (e.g., `primary_bin_full`).\n- Effects of `use_secondary_compost_bin` are generalized as `(fulfilled ?target ?need)` (e.g., the primary bin is no longer full) and `(used ?tool ?target)`.\n\n---\n\n### **Key Features of the Merged Action**:\n1. **Abstract Parameters**:\n   - By using abstract parameters (`?agent`, `?tool`, and `?target`), the action is applicable to a wide variety of tasks involving resource use.\n   \n2. **State Change**:\n   - The action explicitly describes the state change: the tool/resource is used, and the target's need is fulfilled.\n\n3. **Avoiding Redundancy**:\n   - Similar effects from both actions (`nourished` or `used_secondary_bin`) are merged into a single abstract effect (`fulfilled ?target ?need`).\n\n4. **Logical Consistency**:\n   - Preconditions and effects are generalized while preserving their original logic, ensuring the action is consistent across different contexts.\n\n---\n\n### **Example Instantiations of the Merged Action**:\n\n1. **Using Compost**:\n   ```pddl\n   (:action use\n       :parameters (?agent - person ?tool - compost ?target - plant)\n       :precondition (and \n           (ready ?tool) \n           (exists (?soil - attribute) (needs ?target ?soil))\n           (not (used ?tool ?target)))\n       :effect (and \n           (fulfilled ?target ?soil) \n           (used ?tool ?target)))\n   ```\n\n2. **Using Secondary Compost Bin**:\n   ```pddl\n   (:action use\n       :parameters (?agent - person ?tool - secondary_bin ?target - primary_bin)\n       :precondition (and\n           (ready ?tool) \n           (exists (?capacity - attribute) (needs ?target ?capacity))\n           (not (used ?tool ?target)))\n       :effect (and \n           (fulfilled ?target ?capacity) \n           (used ?tool ?target)))\n   ```\n\n---\n\nThis merged action simplifies and generalizes the original actions, ensuring that it is flexible, logically consistent, and efficient across a variety of tasks involving resource use.",
    "```lisp\n(:action inquire ; Inquire about a resource from a specified location\n  :parameters (?p - player ?location - location ?item - item)\n  :precondition (and (at ?p ?location) (exists (?resource - item) (resource_available ?location ?resource)))\n  :effect (and (inventory ?p ?item))\n)\n```\n\n### Explanation of the Merged Action:\n1. **Generality**:\n   - The action `inquire` abstracts the task of collecting a resource from various locations into a single generalized action.\n   - The parameter `?location` can represent any location (e.g., coffee shop, lumberyard, dairy, food processing plant, zoo, city office, etc.).\n   - The parameter `?item` can represent any item (e.g., coffee grinds, sawdust, manure, organic material, compost, etc.).\n\n2. **State Change**:\n   - The precondition `(at ?p ?location)` ensures the player is physically present at the location.\n   - The existence condition `(exists (?resource - item) (resource_available ?location ?resource))` ensures that the resource being inquired about is available at the location.\n   - The effect `(inventory ?p ?item)` reflects the state change where the player successfully acquires the item and adds it to their inventory.\n\n3. **Simplicity and Avoiding Redundancy**:\n   - The merged action consolidates all the specific instances of inquiring (e.g., coffee shop, lumberyard, zoo, etc.) into a single action, avoiding redundancy.\n   - The abstract parameters `?location` and `?item` generalize the functionality, making the action reusable across different contexts.\n\n4. **Logical Consistency**:\n   - The logic of the action remains consistent across different use cases. The preconditions ensure the player is at a valid location and the resource is available, while the effects ensure successful acquisition of the item.\n\nThis merged `inquire` action is now versatile and can be used for a variety of tasks involving resource collection from different locations.",
    "Here\u2019s the merged action for the second set of actions (for `ask`), following the guidelines provided:\n\n```lisp\n(:action ask ; Ask an entity for an item and obtain it\n   :parameters (?requester - person ?giver - entity ?item - object)\n   :precondition (and \n       (at ?requester ?giver) \n       (willing_to_give ?giver) \n       (exists (?available_item - object) (has ?giver ?available_item)))\n   :effect (and (has ?requester ?item))\n)\n```\n\n### Explanation of the Merged Action:\n\n1. **Generality:**\n   - The action is generalized by using abstract parameters (`?requester`, `?giver`, `?item`) that can represent various roles and objects. This allows the action to be adaptable to different tasks involving asking, requesting, or obtaining items.\n\n2. **State Change:**\n   - The action transitions the state by transferring possession of the item (`?item`) from the giver (`?giver`) to the requester (`?requester`), as reflected in the effect `(has ?requester ?item)`.\n\n3. **Core Logic:**\n   - Preconditions ensure that the requester is physically near (`at ?requester ?giver`) and that the giver is willing to give the item (`willing_to_give ?giver`). These preconditions capture the logical requirements for the action.\n   - The effect ensures the requester successfully obtains the item.\n\n4. **Avoid Redundancy:**\n   - The merged action combines multiple similar actions involving asking or requesting an item into one universal action, eliminating duplication.\n\n5. **Logical Consistency:**\n   - The preconditions and effects align with real-world logic and maintain consistency across different contexts. The action ensures that items can only be obtained if they exist and the giver is willing to share them.\n\n---\n\nThis approach creates a universal `ask` action that is adaptable to a wide range of tasks involving requesting or obtaining resources.",
    "Here is the merged **`wait`** action based on the provided tasks and guidelines:\n\n---\n\n### Merged Action: `wait`\n```lisp\n(:action wait\n  :parameters (?entity - object ?context - context ?duration - time)\n  :precondition (and (in ?entity ?context) (prepared ?entity ?context) (not (ready ?entity)))\n  :effect (and (ready ?entity))\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n1. **Generality**:\n   - The action uses abstract parameters `?entity`, `?context`, and `?duration` to allow for flexible application across various scenarios (e.g., waiting for compost to decompose, waiting for a resource to become ready, etc.).\n   - The abstract parameter `?entity` represents any object that undergoes a waiting period (e.g., a compost bin, a container, a task).\n   - The `?context` parameter captures the environment or situation in which the entity exists (e.g., a container, a location, or a specific task).\n   - `?duration` allows for additional flexibility, though it is not directly modeled in the effects or preconditions here (can be used for timing in external systems).\n\n2. **State Change**:\n   - The action transitions the state of an entity from \"prepared\" to \"ready.\"\n   - Preconditions ensure that the `?entity` is in the appropriate `?context` and is in a \"prepared\" state before the waiting process begins.\n   - Effects ensure that the entity is marked as \"ready\" after the waiting period.\n\n3. **Simplicity**:\n   - Irrelevant parameters or overly specific details have been omitted to maintain generality.\n   - By merging similar actions, redundancy is avoided, and the logic is streamlined.\n\n4. **Logical Consistency**:\n   - Preconditions and effects are consistent with the logical progression of a waiting task. The entity must first be in a \"prepared\" state before it transitions to \"ready.\"\n\n---\n\n### Application of the Merged Action:\nThe new `wait` action can be applied to a variety of scenarios, such as:\n- Waiting for a compost bin to decompose after being turned and prepared.\n- Waiting for a resource or item to be ready for use in other contexts.\n\nFor example:\n```lisp\n; Waiting for compost to decompose\n(:action wait\n  :parameters (?bin - container ?compost_area - location ?two_months - time)\n  :precondition (and (in ?bin ?compost_area) (prepared ?bin ?compost_area) (not (ready ?bin)))\n  :effect (and (ready ?bin))\n)\n```\n\nThis unified approach simplifies task definitions, avoids redundancy, and ensures flexibility for a range of scenarios. Let me know if you'd like further refinements!",
    "To merge the provided **transport** actions into a single universal action, we will abstract the parameters, generalize preconditions and effects, and ensure logical consistency while avoiding redundancy. Here's the merged action for **transport**:\n\n### Merged Action: **transport**\n```lisp\n(:action transport\n    ; Transport an item between locations and update its state\n    :parameters (?entity - object ?source - location ?destination - location)\n    :precondition (and\n                    (at ?entity ?source) ; The entity must be at the source location\n                    (accessible ?destination) ; The destination must be accessible\n                    (not (at ?entity ?destination))) ; The entity is not already at the destination\n    :effect (and\n              (at ?entity ?destination) ; The entity is now at the destination\n              (not (at ?entity ?source)) ; The entity is no longer at the source\n              (transformed_state ?entity ?source ?destination))) ; Optional: Capture a state change relevant to the task\n)\n```\n\n### Explanation:\n- **Generality**: The action is generalized to handle the transport of any entity (`?entity`) between any two locations (`?source` and `?destination`). This abstraction allows it to apply to a wide variety of tasks, from moving a compost container to returning it to the kitchen or transporting other objects.\n- **State Change**: The preconditions ensure that the entity starts at the source and the destination is accessible. The effects update the state to reflect that the entity has been moved to the destination and is no longer at the source.\n- **Simplicity**: Redundant conditions or overly specific details (e.g., \"full\" or \"emptied\" for the compost bin) are removed, making the action adaptable to diverse scenarios.\n- **Logical Consistency**: The logic is consistent: an object is transported from one location to another, and its state is updated appropriately.\n\n### Example Use Cases:\n1. **Transporting a Compost Bin to the Compost Area**:\n   - `?entity = compost_bin`\n   - `?source = kitchen`\n   - `?destination = compost_area`\n\n2. **Returning a Compost Container to the Kitchen**:\n   - `?entity = compost_container`\n   - `?source = compost_area`\n   - `?destination = kitchen`\n\n3. **Moving a Box to a Storage Room**:\n   - `?entity = box`\n   - `?source = loading_dock`\n   - `?destination = storage_room`\n\nThis merged action captures the essence of all transport-related operations by using abstract parameters (`?entity`, `?source`, `?destination`) and simple logic to describe the transformation of the entity's state.",
    "Here\u2019s the desired result for the merged action **`setup`** based on the given actions and adhering to your guidelines:\n\n---\n\n### **Merged Action: `setup`**\n\n```lisp\n(:action setup ; Setup a resource or system\n  :parameters (?agent - agent ?resource - object ?location - location)\n  :precondition (and \n    (at ?agent ?location) \n    (has_precondition ?resource ?location) ; Abstracted precondition for adaptability (e.g., soil, materials)\n    (not (setup ?resource))) ; Ensure the resource/system is not already set up\n  :effect (and \n    (setup ?resource) ; Marks the resource/system as set up\n    (ready_for_use ?resource)) ; Indicates the resource/system is ready for its intended purpose\n)\n```\n\n---\n\n### **Explanation of the Merged Action**\n\n#### **Generality**\n- The `setup` action is designed to handle a wide range of tasks that involve preparing or initializing a resource, system, or environment to make it operational.\n- Abstracted parameters:\n  - `?agent` represents any entity (e.g., player, NPC) responsible for performing the setup.\n  - `?resource` represents the object being set up (e.g., compost, system).\n  - `?location` specifies where the setup is taking place.\n\n#### **State Change**\n- **Precondition**:\n  - `at ?agent ?location`: Ensures the agent is at the correct location.\n  - `has_precondition ?resource ?location`: Represents generic requirements for the resource to be set up (e.g., soil availability or specific materials present).\n  - `(not (setup ?resource))`: Ensures the resource/system hasn\u2019t already been set up.\n- **Effect**:\n  - `(setup ?resource)`: Marks the resource/system as set up.\n  - `(ready_for_use ?resource)`: Indicates the resource/system is now functional and ready for its intended purpose.\n\n#### **Core Logic**\n- Consolidates the logic of setting up a composting system (or any similar resource) into a single, abstract framework.\n- Retains the essence of the original actions while generalizing them for broader applicability.\n\n#### **Avoid Redundancy**\n- Combines similar effects (`setup` and `ready_for_composting`) into a unified, abstract effect: `(setup ?resource)` and `(ready_for_use ?resource)`.\n\n#### **Logical Consistency**\n- Maintains a clear and consistent relationship between preconditions and effects across different contexts. For example:\n  - If the agent is at the correct location and the required materials/conditions are met, the resource/system can be set up.\n  - Once set up, the resource/system is marked as ready for use.\n\n---\n\nThis merged action can now be applied to a wide variety of tasks that involve setting up and preparing resources or systems, making it highly versatile and efficient.",
    "The merged action that encapsulates the **\"apply\"** functionality, while maintaining generality, clear state changes, simplicity, and logical consistency, can be represented as follows:\n\n---\n\n### Universal Merged Action: `apply`\n```pddl\n(:action apply\n    :parameters (?actor - agent ?item - object ?target - location)\n    :precondition (and \n        (inventory ?actor ?item)          ; The actor must have the item in their inventory\n        (prepared ?item)                 ; The item must be in a prepared state (e.g., cleaned, processed, or ready for use)\n        (intended_usage ?item applicable) ; The item's intended usage must allow for application\n        (at ?actor ?target)              ; The actor must be at the target location\n    )\n    :effect (and \n        (applied ?item ?target)          ; The item is now applied to the target\n        (not (inventory ?actor ?item))   ; The item is removed from the inventory\n    )\n)\n```\n\n---\n\n### Explanation of the Merged Action:\n\n1. **Generality**:\n   - The action is designed to capture a broad range of \"apply\" tasks, such as applying items to locations, objects, or other entities. \n   - Abstract parameters (`?actor`, `?item`, `?target`) make the action adaptable to diverse scenarios (e.g., applying seaweed to a garden, spreading fertilizer, or attaching a component to a machine).\n\n2. **State Change**:\n   - Preconditions ensure that the item is in a prepared state (`prepared ?item`), the actor possesses the item (`inventory ?actor ?item`), and the actor is at the correct location (`at ?actor ?target`).\n   - The effects transition the item from being in the actor's inventory to being applied to the target location (`applied ?item ?target`) and remove the item from the inventory.\n\n3. **Simplicity**:\n   - Redundant or overly specific conditions (e.g., \"clean ?seaweed\" or \"direct_application\") have been abstracted into the `prepared` and `intended_usage` predicates, simplifying the action's logic while retaining its flexibility.\n\n4. **Logical Consistency**:\n   - The preconditions and effects align logically, ensuring that the action is only executable when the necessary prerequisites are met and resulting in consistent state changes.\n\n---\n\n### Use Case Examples:\n\n#### Applying Seaweed to a Garden\n```pddl\n(:apply \n    :parameters (?p - player ?seaweed - item ?garden - location)\n    :precondition (and \n        (inventory ?p ?seaweed)\n        (prepared ?seaweed)\n        (intended_usage ?seaweed applicable)\n        (at ?p ?garden)\n    )\n    :effect (and \n        (applied ?seaweed ?garden)\n        (not (inventory ?p ?seaweed))\n    )\n)\n```\n\n#### Applying Paint to a Wall\n```pddl\n(:apply \n    :parameters (?worker - agent ?paint - object ?wall - location)\n    :precondition (and \n        (inventory ?worker ?paint)\n        (prepared ?paint)\n        (intended_usage ?paint applicable)\n        (at ?worker ?wall)\n    )\n    :effect (and \n        (applied ?paint ?wall)\n        (not (inventory ?worker ?paint))\n    )\n)\n```\n\n#### Attaching a Component to a Machine\n```pddl\n(:apply \n    :parameters (?engineer - agent ?component - object ?machine - location)\n    :precondition (and \n        (inventory ?engineer ?component)\n        (prepared ?component)\n        (intended_usage ?component applicable)\n        (at ?engineer ?machine)\n    )\n    :effect (and \n        (applied ?component ?machine)\n        (not (inventory ?engineer ?component))\n    )\n)\n```\n\n---\n\n### Summary:\nBy merging the actions into the universal `apply` action, we achieve a highly adaptable and efficient structure that can accommodate a wide variety of tasks involving the application of an item to a target. This universal action is modular, logical, and avoids redundancy while respecting the core principles of PDDL.",
    "Here's how the actions can be merged into a single universal **adjust** action that adheres to the guidelines you've provided:\n\n---\n\n**Action name after merge: adjust**\n\n```lisp\n(:action adjust\n  ; Adjust the state of an entity to meet specific requirements\n  :parameters (?entity - object ?resource - object)\n  :precondition (and (requires-adjustment ?entity) (suitable ?resource))\n  :effect (and (adjusted ?entity) (not (requires-adjustment ?entity)))\n)\n```\n\n---\n\n### Explanation of the Merge Process:\n\n1. **Generality**:\n   - The merged action is abstract and adaptable to different tasks involving adjustments. For example, it could represent adjusting moisture for a tumbler, reconfiguring some state, or performing similar transformations on an entity.\n\n   - The parameters `?entity` and `?resource` are abstract, allowing the action to be applied to a variety of objects or resources, such as a tumbler, water, or another object.\n\n2. **State Change**:\n   - The precondition `(requires-adjustment ?entity)` ensures that the action is only applied when the entity actually needs adjustment, and `(suitable ?resource)` ensures the resource is valid for the adjustment.\n   - The effect `(adjusted ?entity)` indicates that the entity's state has been successfully adjusted, while `(not (requires-adjustment ?entity))` ensures logical consistency by removing the need for further adjustment.\n\n3. **Core Logic**:\n   - Retains the necessary preconditions and effects from the original actions (e.g., \"moist ?t\" and \"not dry ?t\" in the `adjust-moisture` action).\n   - Abstracts the concept of \"moist\" or \"wet\" into a generalized state change represented by `(adjusted ?entity)`.\n\n4. **Avoid Redundancy**:\n   - By merging similar effects (e.g., \"moist ?t\" and \"not dry ?t\"), the action eliminates redundancy and simplifies state representation.\n   - The merged action avoids including unnecessary specifics like \"moist\" and \"wet,\" instead generalizing to \"adjusted.\"\n\n5. **Logical Consistency**:\n   - The logical progression from preconditions to effects is preserved in all cases, ensuring compatibility with different contexts.\n\n---\n\n### Example Applications of the Merged `adjust` Action:\n\n1. **Adjusting Moisture for a Tumbler**:\n   ```lisp\n   (:action adjust\n     :parameters (?t - tumbler ?w - water)\n     :precondition (and (requires-adjustment ?t) (suitable-water ?w))\n     :effect (and (adjusted ?t) (not (requires-adjustment ?t)))\n   )\n   ```\n\n2. **Tumbling a Composter**:\n   ```lisp\n   (:action adjust\n     :parameters (?composter - object ?tool - object)\n     :precondition (and (requires-adjustment ?composter) (suitable-tool ?tool))\n     :effect (and (adjusted ?composter) (not (requires-adjustment ?composter)))\n   )\n   ```\n\n3. **Refilling a Resource**:\n   ```lisp\n   (:action adjust\n     :parameters (?container - object ?resource - object)\n     :precondition (and (requires-adjustment ?container) (suitable-resource ?resource))\n     :effect (and (adjusted ?container) (not (requires-adjustment ?container)))\n   )\n   ```\n\n---\n\n### Final Notes:\n- This universal **adjust** action is highly adaptable to different tasks while maintaining clarity and simplicity.\n- It abstracts away task-specific details but retains the logical structure needed to transform the state of an entity using a suitable resource.",
    "### Merged Action: Harvest\n\nThe following is the single merged action that encapsulates all the relevant steps and logic for the composting process, ensuring generality, state change, simplicity, and logical consistency:\n\n```pddl\n(:action harvest\n  ; Harvest a resource and update its state\n  :parameters (?actor - agent ?resource - object ?location - place)\n  :precondition (and \n      (at ?actor ?location) ; Actor is present at the resource location\n      (in ?resource ?location) ; Resource exists at the location\n      (ready-for-harvest ?resource) ; Resource is in a state ready to be harvested\n  )\n  :effect (and \n      (harvested ?resource) ; Resource is successfully harvested\n      (not (ready-for-harvest ?resource)) ; Resource is no longer in the \"ready\" state\n      (updated ?location) ; Location state is updated after the harvest\n  )\n)\n```\n\n---\n\n### **Explanation of the Merged Action**\n\n#### Generality:\n- The action uses abstract parameters (`?actor`, `?resource`, `?location`) to ensure that it can be adapted to a variety of scenarios, not just limited to compost.\n- For example, it can be used for harvesting compost, crops, or other resources in different contexts.\n\n#### State Change:\n- The precondition `ready-for-harvest ?resource` ensures that the resource is in the correct state before performing the action.\n- The effect `harvested ?resource` transforms the resource's state to indicate it has been harvested.\n- Additional effects (`not (ready-for-harvest ?resource)` and `updated ?location`) ensure that the resource and location state are properly updated after the action.\n\n#### Simplicity:\n- The merged action avoids redundancy by combining all relevant steps (e.g., checking the readiness of the resource, ensuring location constraints) into a single concise logic.\n- It eliminates unnecessary complexity by focusing only on the core logic required to perform the harvest action.\n\n#### Logical Consistency:\n- Preconditions and effects are logically aligned and consistent across different tasks. For example, the resource must be ready for harvest, and once harvested, it cannot remain in the \"ready-for-harvest\" state.\n\n---\n\n### Potential Applications of the Merged Harvest Action\n1. **Composting**:\n   - Actor: `?actor` = compost manager\n   - Resource: `?resource` = compost\n   - Location: `?location` = compost tumbler\n\n2. **Agricultural Harvesting**:\n   - Actor: `?actor` = farmer\n   - Resource: `?resource` = crops\n   - Location: `?location` = farm plot\n\n3. **Resource Collection in Games**:\n   - Actor: `?actor` = player character\n   - Resource: `?resource` = collectible item\n   - Location: `?location` = in-game region or level\n\n---\n\n### Example Instantiation for Harvesting Compost\n```pddl\n(:action harvest\n  :parameters (?manager - person ?compost - resource ?tumbler - tumbler)\n  :precondition (and \n      (at ?manager ?tumbler)\n      (in ?compost ?tumbler)\n      (ready-for-harvest ?compost)\n  )\n  :effect (and \n      (harvested ?compost)\n      (not (ready-for-harvest ?compost))\n      (updated ?tumbler)\n  )\n)\n```\n\nThis instantiation applies the general merged action to the specific task of harvesting compost from a compost tumbler, demonstrating how the universal logic can be adapted to specific scenarios."
]