[
    "### Merged Action: cook\n\nThe merged action set will encompass the preparation, cooking, and final serving of the food items. To maintain generality, we use abstract parameters to adapt to a variety of tasks. Here is the combined PDDL action:\n\n```lisp\n(:action cook\n  :parameters (?p - player ?item1 - entity ?item2 - entity ?tool1 - tool ?tool2 - tool ?loc - location ?appliance - appliance)\n  :precondition (and\n    (inventory ?p ?item1) ; The player has the primary item\n    (at ?item1 ?loc) ; The primary item is at the location\n    (at ?item2 ?loc) ; The secondary item (if any) is at the location\n    (clean ?tool1) ; The primary tool is clean\n    (at-tool ?tool1 ?loc) ; The primary tool is at the location\n    (clean ?tool2) ; The secondary tool (if any) is clean\n    (at-tool ?tool2 ?loc) ; The secondary tool (if any) is at the location\n    (at ?p ?loc) ; The player is at the location\n    (has-power ?appliance) ; The appliance is powered\n    (not (cooked_or_not ?item1 cooked)) ; The item is not yet cooked\n  )\n  :effect (and\n    (cooked_or_not ?item1 cooked) ; The primary item is cooked\n    (not (cooked_or_not ?item1 uncooked)) ; The primary item is no longer uncooked\n    (prepared ?item2) ; The secondary item is prepared\n    (not (whole ?item2)) ; The secondary item is no longer whole\n    (hot_fire ?appliance) ; The appliance has a hot fire\n    (assembled ?item1 ?item2) ; The primary and secondary items are assembled\n    (served ?item1) ; The primary item is served\n    (enjoyed ?item1) ; The primary item is enjoyed\n  )\n)\n```\n\n### Explanation of the Merged Action:\n\n1. **Generality**: The parameters are abstract and can adapt to various tasks, allowing this action to be used for preparing, cooking, and serving different kinds of food items.\n2. **State Change**: The preconditions and effects are designed to reflect the gradual transformation of the entity's state from uncooked to cooked, prepared, assembled, served, and enjoyed.\n3. **Simplicity and Efficiency**: By combining similar actions and avoiding redundancy, the merged action maintains simplicity and efficiency.\n4. **Logical Consistency**: The action maintains consistent logic, with clear preconditions and effects that make sense across different cooking tasks.\n\nThis merged action captures the essence of the various cooking-related tasks and ensures a streamlined, adaptable approach to defining actions in PDDL.",
    "To merge the given actions into a single universal action, we need to ensure the resulting action is abstract, adaptable, and maintains logical consistency across various tasks. Here are the steps to merge the actions \"chill_beef\" and \"season_meat\":\n\n1. Identify common parameters and abstract them.\n2. Define preconditions that are general enough to cover both actions.\n3. Define the effects clearly to show the state change.\n4. Remove any redundancy and ensure the action remains simple and efficient.\n\nLet's start by analyzing the given actions:\n\n### Action 1: chill_beef\n```lisp\n(:action chill_beef\n    :parameters (?p - player ?gc - ground_chuck ?fridge - location)\n    :precondition (and (inventory ?p ?gc) (at ?p ?fridge) (prepared ?gc) (not (chilled ?gc)))\n    :effect (and (chilled ?gc) (not (prepared ?gc)))\n)\n```\n\n### Action 2: season_meat\n```lisp\n(:action season_meat\n    :parameters (?p - player ?meat - meat ?seasoning - seasoning)\n    :precondition (and (inventory ?p ?meat) (inventory ?p ?seasoning) (not (seasoned ?meat)))\n    :effect (seasoned ?meat)\n)\n```\n\n### Merged Action: chill\nBased on the analysis, we can see that both actions involve a player (?p) performing an action on an item (?item) under certain conditions. We will abstract the parameters to make the action more general and adaptable to various tasks.\n\nHere is the merged action:\n\n```lisp\n(:action chill\n  :parameters (?p - player ?item - object ?location - location ?condition - state)\n  :precondition (and (inventory ?p ?item) (at ?p ?location) (not (?condition ?item)))\n  :effect (and (?condition ?item))\n)\n```\n\n### Explanation:\n- **Parameters**: `?p` represents the player, `?item` represents the object (be it ground chuck or meat), `?location` is the location where the action takes place (like a fridge), and `?condition` is the state change we want to achieve (like chilled or seasoned).\n- **Precondition**: The player must have the item in their inventory and be at the specified location. The item should not already be in the desired state (`not (?condition ?item)`).\n- **Effect**: The item achieves the desired state (`?condition ?item`).\n\nThis merged action \"chill\" can now be used for various tasks where an item needs to be transformed into a different state, such as chilling or seasoning, by appropriately substituting the parameters and states.\n\n### Usage Examples:\n- **Chilling Beef**:\n```lisp\n(:action chill\n  :parameters (?p - player ?gc - ground_chuck ?fridge - location ?condition - chilled)\n  :precondition (and (inventory ?p ?gc) (at ?p ?fridge) (not (chilled ?gc)))\n  :effect (and (chilled ?gc))\n)\n```\n- **Seasoning Meat**:\n```lisp\n(:action chill\n  :parameters (?p - player ?meat - meat ?kitchen - location ?condition - seasoned)\n  :precondition (and (inventory ?p ?meat) (at ?p ?kitchen) (not (seasoned ?meat)))\n  :effect (and (seasoned ?meat))\n)\n```\n\nThis approach creates a versatile and efficient action that can adapt to multiple contexts while maintaining logical consistency and simplicity.",
    "To meet the criteria outlined in your request, we need to create a universal action called `place` that combines the actions related to placing or modifying the state of various entities. This universal action should be adaptable to different tasks, capture state changes, and maintain simplicity and consistency. Here is the merged action:\n\n```lisp\n(:action place ; Place an item and update its state\n    :parameters (?actor - agent ?item - object ?location - location ?tool - tool)\n    :precondition (and \n        (available ?actor) ; The actor must be available\n        (not (placed ?item ?location)) ; The item must not already be placed at the location\n        (at ?actor ?location) ; The actor must be at the location\n        (or \n            (and (inventory ?actor ?item)) ; The actor has the item in inventory\n            (and (clean ?tool) (at-tool ?tool ?location)) ; The tool is clean and at the location\n            (and (ready ?item) (at ?item ?location)) ; The item is ready and at the location\n            (and (shaped ?item)) ; The item is shaped (for specific tasks like cooking)\n        )\n    )\n    :effect (and\n        (placed ?item ?location) ; The item is now placed at the location\n        (not (inventory ?actor ?item)) ; The item is no longer in the actor's inventory\n        (not (at ?item ?location)) ; The item is no longer at the initial location\n        (or \n            (seasoned ?item) ; The item is seasoned (for cooking tasks)\n            (in-bowl ?item ?tool) ; The item is placed in the bowl (for mixing tasks)\n            (cooked ?item) ; The item is being cooked (for grilling tasks)\n            (on-plate ?item ?tool) ; The item is placed on the plate (for serving tasks)\n            (flattened ?item) ; The item is flattened (for specific tasks like pressing)\n        )\n        (not (ready ?item)) ; The item is no longer in the ready state\n        (not (shaped ?item)) ; The item is no longer in the shaped state\n    )\n)\n```\n\n### Explanation:\n\n1. **Generality**: The merged action `place` uses abstract parameters (`?actor`, `?item`, `?location`, `?tool`) to apply to various tasks such as cooking, mixing, and serving.\n2. **State Change**: Preconditions and effects describe the changes in the state of the item based on the action performed.\n3. **Simplicity**: The action avoids redundancy by combining similar effects and maintaining a straightforward structure.\n4. **Logical Consistency**: The action retains logical consistency by ensuring preconditions are met before effects are applied.\n\nThis merged action should be adaptable enough to cover a variety of similar tasks while capturing and transforming the entity's state in a clear and logical manner.",
    "To merge the given PDDL actions into a single universal action named `check`, we need to ensure that the resulting action is general, captures state changes, retains core logic, avoids redundancy, and maintains logical consistency across different scenarios.\n\nLet's start by examining the actions that need to be merged:\n\n1. **check_doneness**:\n```lisp\n(:action check_doneness\n    :parameters (?p - player ?patty - patties)\n    :precondition (and (cooking ?patty) (not (checked ?patty)))\n    :effect (checked ?patty)\n)\n```\n\n2. **check_burger_temperature**:\n```lisp\n(:action check_burger_temperature\n    :parameters (?p - player ?grill - grill ?patty - patty)\n    :precondition (and (at ?p ?grill) (on_grill ?patty ?grill) (cooked ?patty))\n    :effect (and (inventory ?p ?patty) (not (on_grill ?patty ?grill)) (tested ?patty))\n)\n```\n\nGiven these actions, we can create a merged action that captures the essence of checking an item (whether it is a patty or another object) and updating its state accordingly. Here is the merged action:\n\n```lisp\n(:action check\n    :parameters (?agent - agent ?item - item ?location - location)\n    :precondition (and \n        (available ?agent) \n        (at ?agent ?location) \n        (or (and (cooking ?item) (not (checked ?item))) \n            (and (on_grill ?item ?location) (cooked ?item)))\n    )\n    :effect (and \n        (checked ?item) \n        (when (on_grill ?item ?location) \n            (and (inventory ?agent ?item) (not (on_grill ?item ?location)) (tested ?item))\n        )\n    )\n)\n```\n\n### Explanation:\n\n- **Generality**: The action `check` is designed to be general, applying to any agent checking any item at a location.\n- **State Change**: The precondition checks whether the item is either cooking (and not checked) or on the grill and cooked. The effects update the item's state to `checked`, and if the item was on the grill, it also updates the agent's inventory and marks the item as `tested`.\n- **Core Logic**: The core logic of checking an item and updating its state is retained.\n- **Avoid Redundancy**: By merging the conditions and effects into a single action, we avoid redundancy.\n- **Logical Consistency**: The action maintains logical consistency by ensuring that the preconditions and effects are reasonable and clearly defined.\n\nThis merged action should be adaptable to various tasks involving checking items and updating their state, making it a versatile and efficient solution.",
    "Based on the given actions, the merged action should generalize the process of serving a food item, either a burger or polenta. The merged action, named `serve`, will need to handle different food items and their respective conditions. Here is the generalized PDDL action:\n\n### Merged Action: serve\n```lisp\n(:action serve\n    :parameters (?entity - entity ?location_before - location ?location_after - location ?condition_before - condition ?condition_after - condition)\n    :precondition (and \n        (at ?entity ?location_before)\n        (has_condition ?entity ?condition_before)\n        (not (served ?entity))\n    )\n    :effect (and\n        (at ?entity ?location_after)\n        (has_condition ?entity ?condition_after)\n        (served ?entity)\n    )\n)\n```\n\n### Explanation:\n- **Generality:** The action is designed to handle any entity (food item) and any location or condition changes, making it adaptable to various tasks.\n- **State Change:** The action preconditions and effects clearly define the state changes - moving the entity from one location to another and changing its condition (e.g., from uncooked to cooked, or from polenta in pot to polenta in bowl).\n- **Simplicity:** The action avoids redundancy by combining similar steps and using abstract parameters to generalize the process.\n- **Logical Consistency:** The preconditions and effects ensure logical consistency across different tasks by defining clear state changes.\n\n### Example Instantiations:\n#### Serving a Burger\n```lisp\n(:action serve_burger\n    :parameters (?p - player ?patty - patties ?bun - item ?plate - location)\n    :precondition (and \n        (at ?patty ?grill)\n        (has_condition ?patty cooked)\n        (not (served ?patty))\n    )\n    :effect (and\n        (at ?patty ?plate)\n        (has_condition ?patty served)\n        (served ?patty)\n    )\n)\n```\n\n#### Serving Polenta\n```lisp\n(:action serve_polenta\n    :parameters (?polenta - entity ?pot - location ?bowl - location ?stove - location)\n    :precondition (and\n        (at ?polenta ?pot)\n        (has_condition ?polenta hot)\n        (not (served ?polenta))\n    )\n    :effect (and\n        (at ?polenta ?bowl)\n        (has_condition ?polenta served)\n        (served ?polenta)\n    )\n)\n```\n\n### Notes:\n- **Parameters:** `?entity` covers any type of food item (e.g., burger patty, polenta). `?location_before` and `?location_after` represent the initial and final locations of the entity. `?condition_before` and `?condition_after` denote the state transitions (e.g., cooked, served).\n- **Preconditions:** Specify that the entity is at a specific location and in a particular condition before it can be served.\n- **Effects:** Define the new location and condition of the entity after serving, and mark it as served.\n\nThis merged action can be instantiated for various tasks by defining appropriate parameters, preconditions, and effects specific to each task, ensuring flexibility and simplicity.",
    "Here is the merged action based on the provided actions and the guidelines specified:\n\n```lisp\n(:action choose ;  Choose a resource and update its status\n  :parameters (?entity - entity ?location - location ?method - method ?appliance - appliance ?container - container)\n  \n  :precondition (and \n    (or (at ?entity ?location) (available ?appliance)) \n    (or (quality ?entity good) (type ?entity ground_beef) (frozen ?entity) (thickness ?entity <= 0.5) (empty ?container)) \n    (or (atLocation ?entity pantry) (atLocation ?entity fridge)) \n    (has_cleanliness ?location clean))\n  \n  :effect (and \n    (or (ready ?entity) (selected ?method) (ready-to-cook ?method) (inventory ?entity) (not (at ?entity fridge)) (inBowl ?entity ?container) (not (atLocation ?entity pantry)) (not (atLocation ?entity fridge)) (at_location ?entity on_counter)))\n)\n```\n\n### Explanation:\n1. **Generality:** \n    - The parameters are abstract (entity, location, method, appliance, container), making the action adaptable to different tasks.\n    - The action name \"choose\" is generic enough to be used in various contexts.\n\n2. **State Change:**\n    - The preconditions and effects are designed to reflect the state changes necessary for different tasks, such as checking quality, selecting cooking methods, and gathering ingredients.\n\n3. **Simplicity:**\n    - The merged action eliminates redundancy by combining similar effects and preconditions.\n    - It retains essential logic without unnecessary complexity.\n\n4. **Logical Consistency:**\n    - The preconditions and effects maintain consistency across different tasks, ensuring that the action can be applied in various scenarios logically.\n\nThis merged action \"choose\" allows for a variety of tasks involving checking, selecting, and gathering resources while updating their states accordingly.",
    "To merge the actions related to chopping and ensure the new action is generalized, maintains state changes, avoids redundancy, and retains logical consistency, we can define a universal \"chop\" action. The merged action will use abstract parameters and cover a variety of chopping tasks.\n\nHere is the resulting merged action:\n\n```lisp\n(:action chop\n    ; Generic chopping action for various ingredients\n    :parameters (?ingredient1 - ingredient ?ingredient2 - ingredient ?tool1 - tool ?tool2 - tool ?loc - location)\n    :precondition (and\n        (at ?ingredient1 ?loc)\n        (at ?ingredient2 ?loc)\n        (at-tool ?tool1 ?loc)\n        (at-tool ?tool2 ?loc)\n        (clean ?tool1)\n        (clean ?tool2)\n    )\n    :effect (and\n        (chopped ?ingredient1)\n        (chopped ?ingredient2)\n        (not (whole ?ingredient1))\n        (not (whole ?ingredient2))\n    )\n)\n```\n\n### Explanation\n1. **Generality**: The merged action uses abstract parameters (`?ingredient1`, `?ingredient2`, `?tool1`, `?tool2`, `?loc`) to ensure it can adapt to various chopping tasks, not limited to specific ingredients or tools.\n2. **State Change**: The preconditions and effects clearly reflect the state changes of the ingredients and tools, transforming them from whole to chopped.\n3. **Simplicity**: The action avoids redundancy by merging similar conditions and ensuring the preconditions and effects remain straightforward.\n4. **Logical Consistency**: The logic of the action remains consistent across different tasks, ensuring that the preconditions and effects are clear and reasonable.\n\nThis merged \"chop\" action can be applied to various tasks involving chopping different ingredients with different tools in a specified location.",
    "To merge the given PDDL actions into a single universal action named \"add,\" we need to consider the guidelines provided: generality, state change, simplicity, and logical consistency. Here is a universal \"add\" action that encapsulates the essence of the provided actions:\n\n```lisp\n(:action add\n  :parameters (?agent - entity ?target - entity ?location - entity ?context - context)\n  :precondition (and\n    (available ?agent)\n    (at_location ?target ?location)\n    (in_context ?context)\n    (not (added ?agent ?target ?context))\n  )\n  :effect (and\n    (added ?agent ?target ?context)\n    (context_state_changed ?context)\n  )\n)\n```\n\n### Explanation:\n1. **Generality**: \n   - The action uses abstract parameters (?agent, ?target, ?location, ?context) to adapt to various tasks such as adding ingredients to a bowl, adding details to a paragraph, and combining ingredients.\n\n2. **State Change**: \n   - The preconditions and effects clearly reflect the state change:\n     - Preconditions ensure the agent is available, the target is at a specific location, the context is relevant, and the action hasn't been performed yet.\n     - Effects indicate that the target has been added by the agent in the specified context and that the context's state has changed as a result.\n\n3. **Simplicity**: \n   - The action avoids redundancy by merging similar effects and removing unnecessary complexity.\n\n4. **Logical Consistency**: \n   - The preconditions and effects maintain consistent logic across different tasks, ensuring reasonable and clear state changes.\n\n### Tasks Covered:\n- **Cooking-related tasks**: Adding ingredients to a bowl, mixing ingredients, and stirring in components.\n- **Writing-related tasks**: Adding details or sentences to a paragraph with specific types (tomato, cheese, lettuce, onion, etc.).\n\n### Example Mappings:\n- **add_egg_yolk**:\n  - `?agent` = chef\n  - `?target` = egg_yolk\n  - `?location` = bowl\n  - `?context` = cooking\n\n- **add_detail_tomato**:\n  - `?agent` = writer\n  - `?target` = detail_tomato\n  - `?location` = paragraph\n  - `?context` = writing\n\n- **stir_in_butter_and_cheese**:\n  - `?agent` = chef\n  - `?target` = butter_and_cheese\n  - `?location` = pot\n  - `?context` = cooking\n\nOverall, this universal \"add\" action can be adapted for various tasks by adjusting the parameters and ensuring the preconditions and effects align with the specific task's context.",
    "Based on the provided guidelines and the examples, here is how we can merge the \"shape_burgers\" action with a more universal action that adapts to a variety of tasks involving shaping or transforming items. \n\n### Merged Action: shape\n\n#### Action sets that need to be merged:\n```lisp\n(:action shape_burgers\n    :parameters (?bowl - tool ?burger - ingredient)\n    :precondition (and\n        (ready-to-shape ?bowl)\n        (clean ?bowl)\n    )\n    :effect (and\n        (shaped ?burger)\n        (not (ready-to-shape ?bowl))\n    )\n)\n```\n\n### Universal Action: shape\n\n#### The merged action:\n```lisp\n(:action shape ; Shape or transform an item using a tool\n    :parameters (?tool - tool ?item - object)\n    :precondition (and\n        (ready-to-shape ?tool)\n        (clean ?tool)\n    )\n    :effect (and\n        (shaped ?item)\n        (not (ready-to-shape ?tool))\n    )\n)\n```\n\n### Explanation:\n1. **Generality**: The merged action uses abstract parameters `?tool` and `?item` to make it applicable to a variety of tasks involving different tools and items, not limited to just burgers.\n2. **State Change**: The preconditions ensure that the tool is ready and clean for shaping. The effects reflect the state change by marking the item as shaped and the tool as no longer ready for shaping.\n3. **Simplicity**: The action is simplified by using general terms and removing any unnecessary complexity.\n4. **Logical Consistency**: The preconditions and effects maintain consistency across different tasks, ensuring clear and reasonable logic.\n\nThis merged action `shape` can now be used in different contexts where an item needs to be shaped or transformed using a tool, following the guidelines provided.",
    "Given the guidelines and the example actions, we will merge the actions related to writing into a single universal action. The goal is to create an adaptable action that can be applied to a variety of writing tasks while maintaining the core logic and ensuring simplicity.\n\n### Merged Action: write\n\n```pddl\n(:action write\n  ; Write a piece of content and update the paragraph's state\n  :parameters (?writer - writer ?content - content ?target - target)\n  :precondition (and (has_idea ?writer ?content) (is_empty ?target))\n  :effect (and (has_content ?target ?content) (not (is_empty ?target)))\n)\n```\n\n### Explanation:\n\n- **Generality:** The action `write` is designed to cover various writing tasks by using abstract parameters such as `?writer` and `?content`, making it adaptable to different contexts.\n- **State Change:** The preconditions and effects clearly describe the transformation of the target's state. Initially, the target is empty, and after the action, it contains the specified content.\n- **Simplicity:** The action is concise, avoiding unnecessary complexity and redundancy.\n- **Logical Consistency:** The preconditions ensure that the writer has the idea and the target is empty before writing. The effects update the target's state to reflect the new content.\n\nBy following these principles, we have created a universal `write` action that can be adapted to a variety of tasks involving writing and updating the state of a target entity.",
    "Given the guidelines and the provided actions for merging, here is the merged action named `analyze`:\n\n```pddl\n(:action analyze ; Analyze and review a paragraph\n  :parameters (?p - writer ?para - paragraph)\n  :precondition (or (has_conclusion ?para ?conclusion) (analyzed ?para))\n  :effect (and \n    (imply (has_conclusion ?para ?conclusion) (analyzed ?para))\n    (imply (analyzed ?para) (reviewed ?para) (improved ?para))\n  )\n)\n```\n\n### Explanation:\n\n1. **Generality**: The merged action `analyze` uses abstract parameters to adapt to multiple tasks, such as analyzing and reviewing paragraphs, thus increasing its applicability.\n2. **State Change**: The preconditions ensure that the entity's state changes in a logical progression from having a conclusion, to being analyzed, and finally to being reviewed and improved.\n3. **Simplicity**: Redundancy is avoided by combining the logic of analyzing and reviewing into a single action, ensuring a streamlined and efficient process.\n4. **Logical Consistency**: The action maintains clear and reasonable preconditions and effects, ensuring a logical progression from analyzing to reviewing and improving the paragraph.\n\nBy merging the actions `analyze_paragraph` and `review_paragraph` into a single action `analyze`, we ensure that the core logic is retained without unnecessary complexity, enhancing both simplicity and efficiency.",
    "Here is the combined action considering the guidelines and the provided examples:\n\n### Action name after merge: toast\n\n```lisp\n(:action toast ; Perform a task on an item and update its status\n  :parameters (?item - object ?tool - object)\n  :precondition (and \n                 (atLocation ?item counter) \n                 (empty ?tool) \n                 (plain ?item))\n  :effect (and \n           (toasted ?item) \n           (flavorful ?item) \n           (not (plain ?item)) \n           (not (bland ?item))\n           (inTool ?item ?tool))\n)\n```\n\n### Explanation:\n\n- **Generality**: The merged action uses abstract parameters (`?item` and `?tool`) to allow for a variety of tasks, ensuring it is not limited to specific types of actions.\n- **State Change**: The preconditions and effects clearly reflect the changes in the state of the item (`?item`), transforming it from plain to toasted and flavorful, and placing it in a tool (`?tool`).\n- **Simplicity**: The merged action avoids redundancy by combining similar effects and removing unnecessary complexity.\n- **Logical Consistency**: The action maintains reasonable preconditions and effects, ensuring that the logic is clear and applicable in different contexts.\n\nBy following these guidelines, the merged action `toast` is both adaptable and efficient, capable of being applied to various tasks involving checking, modifying, or creating items.",
    "Here is the merged action for the tasks provided:\n\n```lisp\n(:action defrost ; Defrost an item and prepare it for cooking\n    :parameters (?p - person ?item - object ?loc - location)\n    :precondition (and \n        (at ?p ?loc) \n        (at ?item ?loc) \n        (or (temperature ?item cold) (clean ?item))\n        (or (ingredient ?item) (tool ?item))\n        (or (appliance ?item) (has-power ?item) (not (heated ?item)))\n    )\n    :effect (and \n        (or (temperature ?item room_temperature) (heated ?item)) \n        (or (not (temperature ?item cold)) (not (at ?item ?loc)))\n        (or (not (clean ?item)) (not (has-power ?item)))\n    )\n)\n```\n\n### Explanation:\n\n**Generality:** \n- The parameters are abstract (e.g., `?p - person`, `?item - object`, `?loc - location`) to make the action adaptable to various tasks involving defrosting and preparing items.\n\n**State Change:**\n- Preconditions and effects are clearly described to reflect the changes in the state. For example, changing the temperature of the item from cold to room temperature and heating it when applicable.\n\n**Simplicity:**\n- Redundancy is avoided by combining conditions that can apply to multiple scenarios (e.g., defrosting meat, warming oil in a pan).\n\n**Logical Consistency:**\n- The action maintains consistent logic across different tasks. The preconditions and effects ensure that items are either defrosted or prepared for the next step in their use (e.g., cooking or handling).\n\nThis merged action now captures the essence of defrosting and preparing items in a single, flexible action.",
    "Here is the merged action called `finish`, which captures the core logic and state changes from the provided actions while ensuring generality, simplicity, and logical consistency:\n\n```lisp\n(:action finish ; Finish a task involving the preparation of items\n  :parameters (?p - player ?item1 - object ?item2 - object ?item3 - object ?container1 - container ?container2 - container ?loc - location)\n  :precondition (and (at ?p ?loc)\n                     (at ?item1 ?loc) (at ?item2 ?loc) (at ?item3 ?loc)\n                     (at ?container1 ?loc) (at ?container2 ?loc)\n                     (or (and (cooked_or_not ?item1 cooked) (location ?item1 in_skillet))\n                         (and (texture ?item1 smooth) (location ?item1 on_wax_paper))\n                         (and (texture ?item1 rigid) (location ?item1 in_pan)))\n                     (cooked_or_not ?item2 cooked)\n                     (texture ?item3 mixed))\n  :effect (and (or (location ?item1 in_bowl) (location ?item1 in_pan) (location ?item1 on_plate))\n               (or (location ?item2 on_plate) (location ?item3 on_plate))\n               (not (location ?item1 in_skillet))\n               (not (location ?item2 on_wax_paper))\n               (texture ?item1 rigid))\n)\n```\n\n### Key Points:\n1. **Generality**: The action is designed with abstract parameters (`?item1`, `?item2`, `?item3`, `?container1`, `?container2`, `?loc`) to handle various tasks and items.\n2. **State Change**: The preconditions and effects clearly reflect the necessary state changes, progressively transforming the entity's state.\n3. **Simplicity**: Redundancy is avoided by merging similar conditions and effects, ensuring the action is simple and efficient.\n4. **Logical Consistency**: Preconditions and effects maintain consistent logic, ensuring they are reasonable in different contexts.\n\nBy consolidating multiple specific actions into a universal `finish` action, we ensure adaptability while retaining the core logic of the original actions.",
    "Here's the merged action for \"enjoy\" based on the provided guidelines and examples:\n\n### Merged Action\n```lisp\n(:action enjoy ; Enjoy a prepared item and update the enjoyment status\n    :parameters (?p - player ?item - object ?loc - location)\n    :precondition (and (at ?p ?loc) (at ?item ?loc) (prepared ?item))\n    :effect (and (enjoyed ?item))\n)\n```\n\n### Explanation:\n\n1. **Generality**: The merged action uses abstract parameters (`?p - player`, `?item - object`, and `?loc - location`) to ensure it can be applied to a variety of tasks involving enjoyment or consumption of prepared items, not limited to specific types of meals or locations.\n\n2. **State Change**: The preconditions reflect the necessary conditions for enjoyment (the player and item must be at the same location, and the item must be prepared). The effect reflects the state change, marking the item as enjoyed.\n\n3. **Simplicity**: The merged action avoids redundancy by combining the essential logical components of the original actions into a single, efficient action without unnecessary complexity.\n\n4. **Logical Consistency**: The preconditions and effects maintain consistent logic, ensuring that an item can only be enjoyed if it is prepared and both the player and item are at the same location. This ensures that the action is reasonable and applicable in different contexts.\n\nBy following these guidelines, the merged action captures the essence of the original actions while being adaptable to a variety of tasks.",
    "### Merged Action: eat\n\n```pddl\n(:action eat\n    :parameters (?p - player ?item - object)\n    :precondition (and (inventory ?p ?item) (cooked ?item) (tested ?item) (temperature ?item >= 140))\n    :effect (and (eaten ?item) (not (inventory ?p ?item)))\n)\n```\n\n### Explanation:\n\n1. **Generality**: The action `eat` uses abstract parameters `?p` (player) and `?item` (object). This abstraction allows the action to be applied to a variety of consumable items, not just burgers or patties.\n\n2. **State Change**: The preconditions ensure that the item is in the player's inventory, has been cooked, tested, and is at a safe temperature. The effect reflects the item being eaten and removed from the inventory, indicating a clear state change.\n\n3. **Simplicity**: By merging actions with similar effects, such as eating different types of food items, redundancy is avoided. The action remains simple and efficient.\n\n4. **Logical Consistency**: The action maintains consistent logic by ensuring that all necessary preconditions for eating an item are met (inventory, cooked, tested, safe temperature) and the effects are logically consistent with the action of eating (item is eaten and removed from inventory).\n\n### Task Flow:\n- **Preheat Grill**: Implied as a prerequisite step before cooking.\n- **Cook Patties**: Ensures patties are properly prepared and cooked.\n- **Check Temperature**: Verifies that the cooked item is safe for consumption.\n- **Eat Burgers**: Final step where the item is consumed if all conditions are met.\n\nThe merged action `eat` effectively captures the essential steps and conditions required for consumption, making it adaptable to different contexts and tasks involving eating or consuming items.",
    "Here's how the merged action `flip` can be defined, ensuring generality, clear state change, simplicity, and logical consistency:\n\n```lisp\n(:action flip ; Flip and process an item\n    :parameters (?item - object ?additional - object ?tool - tool)\n    :precondition (and\n        (in-tool ?item ?tool)\n        (processed_first_side ?item)\n        (available ?additional)\n    )\n    :effect (and\n        (flipped ?item)\n        (processed_second_side ?item)\n    )\n)\n```\n\n### Explanation:\n1. **Generality**:\n   - The action `flip` is designed to be adaptable to various tasks involving flipping and additional processing of an item.\n   - Use of abstract parameters such as `?item`, `?additional`, and `?tool` makes it applicable to different scenarios.\n\n2. **State Change**:\n   - Preconditions specify the conditions required before the action can take place, such as the item being in a tool, its first side being processed, and the availability of an additional object.\n   - Effects clearly define the new state after the action: the item is flipped and its second side is processed.\n\n3. **Simplicity**:\n   - Redundant details have been removed, focusing on the core logic of the action.\n   - The merged action is kept simple by combining similar state changes into one unified effect.\n\n4. **Logical Consistency**:\n   - Preconditions and effects are logically consistent and reasonable for different contexts.\n   - The action maintains clear and reasonable conditions and outcomes across various applicable tasks.",
    "Given the provided task guidelines and examples, I will merge the actions for `prep_bread`, `prep_sauce`, and `cook_meat` into a single, universal action named `prep`. This action will use abstract parameters to generalize across various tasks, ensuring logical consistency, state change clarity, simplicity, and avoidance of redundancy.\n\nHere is the merged action:\n\n```lisp\n(:action prep ; Prepare an item by changing its state\n    :parameters (?p - player ?item - object ?loc - location ?state1 - state ?state2 - state)\n    :precondition (and (at ?p ?loc) (at ?item ?loc) (?state1 ?item))\n    :effect (and (?state2 ?item) (not (?state1 ?item)))\n)\n```\n\n### Explanation:\n\n**Generality**:\n- The action `prep` can be applied to various tasks by using abstract parameters like `?item` and states `?state1` and `?state2`. This makes it adaptable to different preparation tasks such as warming dough, mixing ingredients, or cooking meat.\n\n**State Change**:\n- The preconditions clearly set the initial state of the item (e.g., `cold`, `separate`, etc.), and the effects describe the transformation to the new state (e.g., `warm`, `mixed`, etc.).\n\n**Simplicity**:\n- By merging the actions into a single action with abstract parameters, redundancy is avoided, and the action remains simple and efficient.\n\n**Logical Consistency**:\n- The preconditions and effects ensure that the transformation logic is consistent across different contexts, maintaining a clear and reasonable change in the item's state.\n\n### Original Actions for Reference:\n\n1. **Prep Bread**:\n    ```lisp\n    (:action prep_bread\n        :parameters (?p - player ?dough - bread_dough ?loc - location)\n        :precondition (and (at ?p ?loc) (at ?dough ?loc) (temperature ?dough cold) (location ?dough in_bowl))\n        :effect (and (temperature ?dough warm) (location ?dough on_wax_paper) (not (location ?dough in_bowl)))\n    )\n    ```\n\n2. **Prep Sauce**:\n    ```lisp\n    (:action prep_sauce\n        :parameters (?p - player ?ingredients - sauce_ingredients ?bowl - mixing_bowl ?loc - location)\n        :precondition (and (at ?p ?loc) (at ?ingredients ?loc) (at ?bowl ?loc) (composition ?ingredients separate))\n        :effect (and (composition ?ingredients mixed) (location ?ingredients in_bowl) (not (composition ?ingredients separate)))\n    )\n    ```\n\n3. **Cook the Meat**:\n    ```lisp\n    (:action cook_meat\n        :parameters (?p - player ?meat - meat ?loc - location)\n        :precondition (and (at ?p ?loc) (at ?meat ?loc) (state ?meat raw))\n        :effect (and (state ?meat cooked) (not (state ?meat raw)))\n    )\n    ```\n\n### Merged Action:\n\n```lisp\n(:action prep ; Prepare an item by changing its state\n    :parameters (?p - player ?item - object ?loc - location ?state1 - state ?state2 - state)\n    :precondition (and (at ?p ?loc) (at ?item ?loc) (?state1 ?item))\n    :effect (and (?state2 ?item) (not (?state1 ?item)))\n)\n```",
    "(:action preheat ; Preheat a device or resource\n    :parameters (?actor - agent ?device - object)\n    :precondition (and (at ?actor ?device) (not (on ?device)))\n    :effect (and (on ?device) (preheated ?device))\n)\n\n---\n\n### Explanation and Guidelines Followed:\n1. **Generality**: The merged action uses abstract parameters (`?actor - agent`, `?device - object`) to ensure that it can apply to a variety of tasks beyond just preheating a grill. This makes the action adaptable to different contexts where preheating or activating a device/resource is required.\n\n2. **State Change**: The preconditions and effects clearly describe the state change:\n   - Preconditions ensure that the actor is at the device and that the device is not already on.\n   - Effects indicate that the device is turned on and preheated.\n\n3. **Simplicity and Efficiency**: The action is concise, avoiding redundancy by merging similar effects and maintaining a clear and simple structure.\n\n4. **Logical Consistency**: The preconditions and effects are reasonable and maintain logical consistency across different potential uses of the action. The action ensures that the device is not already on before preheating and that it becomes preheated as a result.\n\nBy following these guidelines, the merged action is versatile, efficient, and logically coherent, making it applicable to a wide range of tasks involving preheating or activating resources."
]