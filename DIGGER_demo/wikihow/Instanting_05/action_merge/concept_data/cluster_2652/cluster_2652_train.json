[
    "To merge the provided PDDL actions into a single universal action, let's first analyze the commonalities and abstract the core logic, as per the guidelines. The actions provided generally involve adding materials to a location, checking or modifying states, and collecting items for a purpose. We'll create a generalized action that can be applied to these tasks.\n\n### Merged Action: `manage_resource`\n\n```pddl\n(:action manage_resource\n    :parameters (?actor - entity ?resource - object ?location - location ?tool - object)\n    :precondition (and \n                    (available ?actor)\n                    (or (in_inventory ?actor ?resource)\n                        (at ?resource ?location))\n                    (or (open ?location)\n                        (empty ?location))\n                    (not (managed ?resource ?location)))\n    :effect (and \n              (managed ?resource ?location)\n              (not (in_inventory ?actor ?resource))\n              (or (in ?resource ?location)\n                  (not (empty ?location)))\n              (not (at ?resource ?location)))\n)\n```\n\n### Explanation of the Merged Action\n\n1. **Generality**:\n   - The action `manage_resource` uses abstract parameters such as `?actor`, `?resource`, `?location`, and `?tool`, making it adaptable to various tasks like adding, checking, or modifying resources.\n   - It can apply to any entity managing any resource at any location, thus increasing its applicability.\n\n2. **State Change**:\n   - The preconditions ensure the actor is available and the resource is either in inventory or at a location, and the location is open or empty.\n   - The effects reflect a state change where the resource is managed at the location, removed from inventory, or no longer at its previous location.\n\n3. **Simplicity**:\n   - Redundancy is reduced by integrating similar actions into a single, abstract form. \n   - It captures the essence of handling resources without unnecessary complexity.\n\n4. **Logical Consistency**:\n   - The preconditions and effects maintain consistent logic by ensuring the action only occurs if the resource can be managed.\n   - The logical flow from preconditions to effects is clear and reasonable across different tasks.\n\nThis merged action effectively combines the core logic of checking, adding, and collecting actions into a singular, versatile framework that can adapt to a wide range of scenarios.",
    "To merge the given PDDL actions into a single universal action named \"choose,\" we need to abstract the parameters and unify the state changes while maintaining logical consistency and avoiding redundancy. Here is the merged action:\n\n```pddl\n(:action choose\n    :parameters (?entity - entity ?target - target)\n    :precondition (and\n                    (not (chosen ?entity ?target))\n                    (available ?entity))\n    :effect (and\n              (chosen ?entity ?target)\n              (not (unselected ?target)))\n)\n```\n\n### Explanation:\n\n- **Generality**: The action is designed to be applicable across various tasks by using abstract parameters `?entity` and `?target`, which can represent different types of entities and targets, such as areas, uses, locations, or bins.\n\n- **State Change**: The precondition `(not (chosen ?entity ?target))` ensures that the action can only be applied if the target has not yet been chosen by the entity. The effect `(chosen ?entity ?target)` reflects the state change indicating that the target has now been selected or chosen by the entity, and `(not (unselected ?target))` ensures logical consistency by removing the unselected state.\n\n- **Simplicity**: The action consolidates similar effects from the original actions, focusing on the state transition from unselected to selected, and ensures no redundancy by combining similar logic.\n\n- **Logical Consistency**: The action maintains reasonable preconditions and effects, ensuring that the state change is clear and adaptable to various contexts, such as choosing an area, a use for an item, or a location for an object.\n\nThis merged action can be used in scenarios where an entity needs to choose or select a target, reflecting the changes in the task status and ensuring logical consistency across different contexts.",
    "To merge the given set of actions into a single, universal action named \"lay,\" we need to focus on abstracting parameters, ensuring logical consistency, and capturing the essence of the state changes involved. Here's how the universal action \"lay\" could be defined:\n\n```pddl\n(:action lay ; General action to manipulate resources and modify state\n  :parameters (?entity - entity ?resource - resource ?location - location)\n  :precondition (and \n                  (available ?entity) \n                  (has ?entity ?resource) \n                  (at ?entity ?location)\n                  (not (organized ?resource)) \n                  (state ?location neutral))\n  :effect (and \n            (organized ?resource) \n            (not (has ?entity ?resource)) \n            (state ?location modified))\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The parameters are abstract (`?entity`, `?resource`, `?location`) to make the action applicable across various contexts, such as laying materials, building containers, or turning on an oven.\n\n2. **State Change**:\n   - Preconditions and effects capture the transition from an initial state to a modified state, aligning with tasks like organizing resources or modifying the state of a location (e.g., a container becoming fuller).\n\n3. **Simplicity**:\n   - Redundancies are removed by using abstract conditions and effects, focusing on the essence of transformation (e.g., organizing, state change).\n\n4. **Logical Consistency**:\n   - The action maintains consistent logic with clear preconditions and effects that can apply to different scenarios without losing meaning.\n\nThis merged action \"lay\" can adapt to numerous tasks involving the manipulation of resources and modification of states, thus achieving the goal of universality and simplicity.",
    "To merge the given actions into a single \"roll\" action that maintains generality, ensures state change, avoids redundancy, and maintains logical consistency, we can create the following action:\n\n```pddl\n(:action roll ; Roll an object to change its state\n  :parameters (?actor - agent ?object - entity)\n  :precondition (and\n                  (precondition1 ?object)\n                  (precondition2 ?actor))\n  :effect (and\n            (changed_state1 ?object)\n            (changed_state2 ?actor))\n)\n```\n\n**Explanation:**\n\n1. **Generality:** The action is named \"roll\" and is designed to be applicable to a variety of tasks involving rolling or changing the state of an object. The parameters `?actor` and `?object` are abstract and can represent a wide range of agents and entities, respectively.\n\n2. **State Change:** \n   - The preconditions `(precondition1 ?object)` and `(precondition2 ?actor)` represent conditions necessary for the action to take place, such as the object being in a certain state or the actor being visible.\n   - The effects `(changed_state1 ?object)` and `(changed_state2 ?actor)` represent the transformation of the object's and actor's states, such as an object being rolled or an actor becoming invisible.\n\n3. **Simplicity and Avoiding Redundancy:** The merged action captures the essence of both original actions without unnecessary complexity. Common effects like changing the visibility of the actor or altering the temperature/state of the object are merged into abstract state changes.\n\n4. **Logical Consistency:** The action maintains logical consistency by ensuring that preconditions and effects are contextually reasonable, allowing the action to be applied in various scenarios while maintaining coherent logic.\n\nThis merged action can be adapted to various tasks by specifying the relevant preconditions and effects for different scenarios, making it versatile and efficient.",
    "To merge the given actions into a single universal action named \"wash,\" we need to abstract the parameters and harmonize preconditions and effects while ensuring logical consistency and avoiding redundancy. Here's how the merged action can be structured:\n\n```pddl\n(:action wash ; Perform a cleaning or preparation task on an item\n    :parameters (?entity - entity ?item - object ?location - location)\n    :precondition (and \n        (at ?entity ?location) \n        (not (processed ?item))\n        (or \n            (inventory ?entity ?item)\n            (location ?item in_waste_basket)\n            (moisture ?item dry)\n            (mixed ?item ?entity)\n        )\n    )\n    :effect (and \n        (processed ?item)\n        (or \n            (clean ?item)\n            (sealed ?item)\n            (moisture ?item wet)\n            (knowledge ?entity selected)\n            (location ?item in_tumbler)\n        )\n    )\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The action \"wash\" uses abstract parameters such as `?entity`, `?item`, and `?location` to apply to a broad range of tasks, including washing, sealing, filling, and spraying.\n\n2. **State Change**:\n   - The precondition `(not (processed ?item))` ensures that the item is in a state requiring action.\n   - The effects transform the item's state to `(processed ?item)`, indicating that the task is completed.\n\n3. **Core Logic**:\n   - The core logic is retained by ensuring that the preconditions and effects cover all scenarios from the original actions, such as `clean`, `sealed`, `moisture`, and `knowledge`.\n\n4. **Avoid Redundancy**:\n   - By merging similar effects (e.g., cleaning, sealing, wetting), redundancy is minimized, and efficiency is maximized.\n\n5. **Logical Consistency**:\n   - Preconditions and effects are logically consistent across different contexts, allowing the action to be used flexibly for various tasks.\n\nThis merged action provides a versatile framework for performing tasks related to washing, sealing, and preparing items, with clear state transformations and logical consistency.",
    "To create a merged PDDL action called `use` that generalizes the given actions, we need to focus on the commonalities in parameters, preconditions, and effects across the different actions. The goal is to maintain the core logic while increasing generality and simplicity.\n\n**Merged Action:**\n\n```pddl\n(:action use ; Use a resource to achieve a task\n  :parameters (?actor - agent ?resource - resource ?location - location)\n  :precondition (and \n                  (has ?actor ?resource) ; The actor has the resource\n                  (at ?actor ?location) ; The actor is at the location\n                  (prepared ?resource)) ; The resource is prepared for use\n  :effect (and\n            (used ?resource) ; The resource is used\n            (task_completed ?actor ?location) ; Task at the location is completed\n            (not (has ?actor ?resource))) ; The resource is no longer with the actor\n)\n```\n\n**Explanation:**\n\n1. **Generality**: The action `use` is designed to be applicable to a wide range of tasks involving resources being used by an agent. The parameters are abstracted to `?actor`, `?resource`, and `?location`, allowing the action to be applied to various scenarios.\n\n2. **State Change**: The preconditions ensure that the `actor` has the `resource`, is at the `location`, and that the `resource` is prepared (clean, consistent, etc.). The effects reflect the use of the `resource`, completion of a task, and the removal of the `resource` from the `actor`.\n\n3. **Simplicity**: By focusing on the core logic of using a resource, the action avoids redundancy and unnecessary complexity. The preconditions and effects are generalized to apply to multiple contexts.\n\n4. **Logical Consistency**: The action maintains a logical flow from preconditions to effects, ensuring that the sequence of events is reasonable and applicable across different tasks.\n\nThis merged action captures the essence of using various resources (like seaweed or compost) while being adaptable to different tasks and contexts.",
    "To create a merged action named \"initiate\" that can be applied to a variety of tasks, we need to abstract the parameters and ensure the state changes and logic remain consistent while avoiding redundancy. Here's how the merged action can be structured:\n\n```pddl\n(:action initiate\n    :parameters (?actor - entity ?target - object)\n    :precondition (and (ready ?actor) (condition ?target initial))\n    :effect (and (condition ?target activated) (state ?actor engaged))\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The `?actor` parameter is abstracted as `entity`, making it applicable to any agent-like entity.\n   - The `?target` parameter is abstracted as `object`, allowing it to represent any targetable object in various contexts.\n\n2. **State Change**:\n   - The precondition uses `condition ?target initial` to represent the initial state of the target object, which is analogous to the specific conditions (e.g., location or inventory) in the original actions.\n   - The effect uses `condition ?target activated` to represent the target's new state, reflecting changes such as visibility or ignition.\n\n3. **Simplicity**:\n   - The parameters and conditions are generalized to make the action applicable to a variety of scenarios, reducing complexity while maintaining core logic.\n\n4. **Logical Consistency**:\n   - The precondition `ready ?actor` ensures the actor is in a state suitable for initiating the action.\n   - The effect `state ?actor engaged` represents the actor's new state after the action, ensuring logical progression and consistency.\n\nBy abstracting the parameters and focusing on core logic, the merged action \"initiate\" can be applied to different tasks while maintaining clarity and efficiency.",
    "To create a merged PDDL action named `balance` from the provided action sets, we need to ensure that the merged action captures the essence of balancing or achieving equilibrium, which can be applied to various contexts. This includes managing resources, time, and conditions. Here's how we can construct it:\n\n### Action Name: `balance`\n\n```pddl\n(:action balance ; Balance resources, conditions, and time\n :parameters (?entity - entity ?resource - resource ?condition - condition ?time - time)\n :precondition (and (location ?resource out_of_place) \n                    (cleanness ?entity clean) \n                    (time ?time earlier)\n                    (not (balanced ?entity ?resource ?condition ?time)))\n :effect (and (cleanness ?entity dirty)\n              (fullness ?resource fuller)\n              (time ?time later)\n              (completion ?time finished)\n              (balanced ?entity ?resource ?condition ?time)))\n```\n\n### Explanation:\n\n- **Generality:** The merged action uses abstract parameters such as `?entity`, `?resource`, `?condition`, and `?time` to allow for a wide range of tasks. This flexibility makes the action applicable to various scenarios that involve balancing resources, managing conditions, and waiting over time.\n  \n- **State Change:** \n  - The preconditions include a resource being out of place, an entity being clean, and time being earlier, indicating the initial unbalanced state.\n  - The effects indicate the transition to a more balanced state, where the entity becomes dirty (indicating use or interaction), the resource becomes fuller (indicating adjustment or fulfillment), and time moves forward, marking the completion of a balancing process.\n\n- **Simplicity and Avoidance of Redundancy:** The merged action maintains simplicity by abstracting specific concepts into a generalized form and avoiding unnecessary complexity. It consolidates the logic of balancing resources and time into a single, coherent action.\n\n- **Logical Consistency:** The action retains logical consistency by ensuring that the preconditions and effects are reasonable and achievable within various contexts. It clearly defines what constitutes an unbalanced state and how the action progresses toward equilibrium.\n\nThis merged action can be adapted to numerous tasks involving balancing, such as resource allocation, state adjustments, or time management, making it broadly applicable across different domains.",
    "\nTo merge the given PDDL actions into a single universal action with the name \"watch,\" we need to ensure that the merged action is general, captures the necessary state changes, and maintains logical consistency while avoiding redundancy. Here's how you can combine the provided actions:\n\n```pddl\n(:action watch ; Monitor an entity's condition and update its status\n    :parameters (?entity - object)\n    :precondition (and (observable ?entity) (inconsistent ?entity))\n    :effect (and (consistent ?entity) (not (inconsistent ?entity)))\n)\n```\n\n### Explanation:\n\n1. **Generality**: The `watch` action uses a generic parameter `?entity - object`, making it applicable to various objects or entities that require monitoring. This abstraction allows the action to be adapted to different tasks involving similar state changes.\n\n2. **State Change**: The preconditions and effects clearly describe a state transition from being \"inconsistent\" to \"consistent.\" This reflects the transformation of the entity's state in a straightforward manner.\n\n3. **Simplicity and Logical Consistency**: The merged action is simplified to capture the essence of both original actions. It avoids redundancy by combining similar effects and maintains logical consistency by ensuring that preconditions and effects are applicable across different contexts.\n\n4. **Core Logic**: The logic of observing and updating the status of an entity is retained. The preconditions ensure that the entity is in a state that requires observation, and the effects reflect the result of the monitoring process (i.e., achieving consistency).\n\nThis merged action effectively combines the functionality of monitoring temperature and observing color and consistency into a single, adaptable action that can be applied to various entities and conditions.",
    "To merge the provided actions into a single, universal action while adhering to the given guidelines, we need to abstract and generalize the parameters, preconditions, and effects so that the merged action can be adaptable to multiple contexts. Here's how the merged action might look:\n\n```pddl\n(:action keep ; Maintain or transform the state of a resource\n  :parameters (?entity - object ?state1 - state ?state2 - state)\n  :precondition (and (in_state ?entity ?state1) (condition ?entity))\n  :effect (and (in_state ?entity ?state2) (not (in_state ?entity ?state1)))\n)\n```\n\n### Explanation:\n\n1. **Generality:**\n   - The action uses abstract parameters such as `?entity`, `?state1`, and `?state2` to make it adaptable for various tasks. The `?entity` can refer to any object (e.g., compost, bin, baking soda), and `?state1` and `?state2` represent different states of the entity (e.g., dry to moist, cold to hot, unobtained to obtained).\n\n2. **State Change:**\n   - The precondition `in_state ?entity ?state1` checks if the entity is currently in a specific state. The effect `in_state ?entity ?state2` changes the state of the entity, while `not (in_state ?entity ?state1)` ensures the previous state is no longer valid.\n\n3. **Simplicity:**\n   - The action does not include unnecessary complexity. It focuses on the core logic of state transformation, making it simple and efficient.\n\n4. **Logical Consistency:**\n   - The preconditions and effects are consistent across different contexts, ensuring that the logic applies to a variety of tasks involving maintaining or transforming the state of an entity.\n\nBy following these guidelines, the merged action is adaptable, logically consistent, and efficient, making it suitable for a range of scenarios described by the original actions.",
    "To merge the given actions into a single universal action named \"inquire,\" we need to generalize the parameters and preconditions, while ensuring the effects reflect the state changes described in the original actions. Here's how the merged action would look:\n\n```pddl\n(:action inquire ; Inquire about obtaining an item from a specific location\n  :parameters (?npc - player ?location - location ?item - object)\n  :precondition (and (at ?npc ?location) (source_location ?location))\n  :effect (and (inventory ?npc ?item) (not (at ?item ?location)))\n)\n```\n\n### Explanation:\n\n1. **Generality:** \n   - The parameters have been generalized to use `?location` and `?item` instead of specific names like `?shop` and `?coffee_grinds`. This allows the action to be applied to various scenarios beyond coffee shops and lumberyards.\n\n2. **State Change:** \n   - The precondition checks if the `?npc` is at the `?location` and that the location is a source for items using the generalized predicate `(source_location ?location)`. This ensures that the action is applicable to any location where items can be inquired.\n   - The effect updates the inventory of the `?npc` with the `?item` and ensures the item is no longer at the `?location`, reflecting the transfer of the item from the location to the player's inventory.\n\n3. **Simplicity and Logical Consistency:**\n   - The merged action maintains the core logic of both original actions without unnecessary complexity. \n   - The logical consistency is ensured by using abstract predicates and parameters, making the action versatile across different contexts and tasks. \n\nThis merged action is adaptable to any scenario where a player inquires about obtaining an item from a specific location, effectively covering the functionality of the original actions.",
    "To merge the given actions into a single universal action named `visit`, we need to identify the commonalities between the actions, abstract the parameters, and ensure that the merged action is general enough to apply to various contexts. Here\u2019s how the merged action would look:\n\n```pddl\n(:action visit ; Visit a location to retrieve an item\n    :parameters (?npc - person ?location - location ?item - object)\n    :precondition (and (at ?npc ?location) (location_type ?location))\n    :effect (and (inventory ?npc ?item) (not (at ?item ?location)))\n)\n```\n\n### Explanation:\n\n1. **Generality:**\n   - The parameters are abstracted to be more general: `?npc` is a person (covering both players and other entities), `?location` is a location (covering both zoo and Christmas tree lot), and `?item` is an object (covering both compost and mulch).\n\n2. **State Change:**\n   - The precondition checks that the `?npc` is at the `?location` and that the `?location` is of a certain type (`location_type`), which can be further defined in the domain to include different types like `zoo`, `christmas_tree_lot`, etc.\n   - The effect captures the state change where the `?npc` gains the `?item` in their inventory and the `?item` is no longer at the `?location`.\n\n3. **Simplicity and Avoiding Redundancy:**\n   - The action removes specific location types from the preconditions (i.e., `zoo ?zoo` and `christmas_tree_lot ?lot`) and replaces them with a general `location_type` predicate.\n   - The effects are combined in the same manner, ensuring that the logic remains consistent without redundancy.\n\n4. **Logical Consistency:**\n   - The merged action maintains logical consistency by ensuring that the preconditions and effects are applicable across different contexts and types of locations, without adding unnecessary complexity. \n\nThis merged action can now be used for various tasks that involve visiting a location to retrieve an item, while maintaining the core logic of the original actions.",
    "(:action determine ; Determine the state of a subject and update knowledge\n:parameters (?entity - agent ?subject - object)\n:precondition (and (knowledge ?entity ?subject unselected))\n:effect (knowledge ?entity ?subject selected))",
    "To create a merged action that is adaptable to multiple tasks involving composting, we need to abstract the parameters and ensure that the preconditions and effects are generalized. Here's how we can define the merged action for composting:\n\n```pddl\n(:action compost\n  ; Compost an item and update its location status\n  :parameters (?agent - agent ?item - compostable ?from - location ?to - location)\n  :precondition (and (at ?agent ?from) (location ?item ?from))\n  :effect (and (location ?item ?to))\n)\n```\n\n### Explanation:\n\n- **Generality**: The action uses abstract parameters such as `?agent`, `?item`, `?from`, and `?to` to apply to a variety of composting tasks. This allows the action to be used for composting different items by different agents at different locations.\n\n- **State Change**: The precondition specifies that the agent must be at a certain location and the item must be at that location. The effect changes the location of the item, reflecting the act of composting by moving it from one location to another.\n\n- **Simplicity**: The action is simple and efficient, focusing on the key state change involved in composting without unnecessary complexity.\n\n- **Logical Consistency**: The logic of moving an item from one location to another is consistent across different composting tasks. This action can be adapted to various scenarios where composting involves a change in the item's location.",
    "To merge the given actions into a single, universal action named \"contact\", we'll need to ensure that the new action is general, maintains logical consistency, reflects clear state changes, and avoids redundancy. Here's how the merged action can be structured:\n\n```pddl\n(:action contact ; Contact a location to acquire resources\n  :parameters (?npc - player ?location - location ?resource - item)\n  :precondition (and (at ?npc ?location) (resource_source ?location))\n  :effect (and (inventory ?npc ?resource) (not (at ?resource ?location)))\n)\n```\n\n### Explanation:\n1. **Generality:**\n   - The action is applicable to any scenario where a player (npc) needs to contact a location to acquire a resource.\n   - `?location` and `?resource` are abstract parameters that can represent any location and resource, making the action flexible.\n\n2. **State Change:**\n   - Preconditions ensure that the player is at the correct location and that the location is a valid resource source.\n   - The effect captures the state change: the resource is added to the npc's inventory and removed from the location, indicating successful acquisition.\n\n3. **Core Logic:**\n   - The core logic of preconditions and effects from the original actions is preserved, ensuring that the merged action still functions correctly across different contexts.\n\n4. **Avoid Redundancy:**\n   - Similar actions have been merged into this single action by using a more generic precondition `(resource_source ?location)`, which can be satisfied if the location is any type of resource provider (such as a dairy, food plant, or government office).\n\n5. **Logical Consistency:**\n   - The action maintains consistent logic by ensuring that the preconditions and effects are reasonable and applicable in different scenarios.\n\nThis merged action can now be used in a variety of tasks involving contacting different types of locations to acquire resources, thus fulfilling the requirements for generality, simplicity, logical consistency, and clear state changes.",
    "To create a merged action named \"be\" from the given action set, we need to generalize the parameters and simplify the preconditions and effects while ensuring logical consistency. Here's how the merged action could be structured:\n\n```lisp\n(:action be ; Engage in a collaborative or resource-sharing activity\n    :parameters (?entity - agent ?location - place)\n    :precondition (and (at ?entity ?location) (collaborative ?location))\n    :effect (shared_resources ?entity ?location)\n)\n```\n\n### Explanation:\n\n1. **Generality:** \n   - Parameters are abstracted as `?entity` and `?location` to represent any agent (e.g., person, player) and any place, respectively, allowing for adaptable use across various tasks.\n   - The action name \"be\" suggests a state of engagement or interaction, which can apply to different contexts.\n\n2. **State Change:** \n   - Preconditions ensure that the entity is at a specified location and the location has a collaborative nature.\n   - The effect captures the result of the action: resources are shared between the entity and the location, indicating a state change.\n\n3. **Simplicity:** \n   - The action is free from redundancy and unnecessary complexity, focusing on a single interaction or event.\n\n4. **Logical Consistency:** \n   - The preconditions and effects are clearly defined, making it applicable in different contexts where collaboration or sharing is involved.\n\nThis merged action framework allows the \"be\" action to be used flexibly in scenarios requiring agents to engage with locations collaboratively or resourcefully.",
    "To merge the given PDDL actions into a single universal action named \"in,\" we need to ensure that the merged action is generalized, maintains logical consistency, and efficiently describes the state changes. Here is the merged action:\n\n```lisp\n(:action in ; Move an entity into a container or location\n :parameters (?entity - object ?location - place)\n :precondition (and (at ?entity ?source) (not (in ?entity ?location)))\n :effect (and (in ?entity ?location) (not (at ?entity ?source)))\n)\n```\n\n### Explanation:\n\n1. **Generality**: The action uses abstract parameters (`?entity` and `?location`) that can be adapted to various contexts, such as moving an object into a container or relocating an entity to a different place.\n\n2. **State Change**: The precondition ensures that the entity is currently at a different location (`?source`) and not already in the desired location (`?location`). The effect updates the entity's state to be in the new location while removing it from the source location.\n\n3. **Simplicity**: By using abstract parameters and focusing on the core logic of moving an entity, the action avoids redundancy and unnecessary complexity.\n\n4. **Logical Consistency**: The action maintains a clear and reasonable logic, ensuring that the preconditions and effects are consistent across different contexts.\n\nThis merged action can be applied to multiple scenarios involving checking, modifying, or creating states related to the placement or location of entities."
]