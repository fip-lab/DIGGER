[
    "To create a merged PDDL action named `cover` that combines the given actions while adhering to the guidelines of generality, state change, simplicity, and logical consistency, we need to abstract the parameters and merge the preconditions and effects. Here's how the merged action could look:\n\n```lisp\n(:action cover ; Cover or transform an item's state using available resources\n    :parameters (?entity - object ?resource - object)\n    :precondition (and \n                   (needs_covering ?entity) \n                   (resource_available ?resource))\n    :effect (and \n             (covered ?entity) \n             (not (needs_covering ?entity)))\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The parameters are abstracted to `?entity` and `?resource` to apply to various tasks involving covering or transforming an item's state. This makes it adaptable to different tasks similar to those described in the examples.\n\n2. **State Change**:\n   - The precondition `(needs_covering ?entity)` generalizes the need for a state change (e.g., `frizzy_braids`, `unruly_hairlines`) and the availability of a resource `(resource_available ?resource)` (e.g., `hot_water_available`, `scarf_available`).\n   - The effect `(covered ?entity)` indicates the state is transformed, similar to `set_braids`, `camouflaged_roots`, etc.\n\n3. **Simplicity**:\n   - Redundancy is avoided by combining similar effects into a single `covered` effect, simplifying the logic for covering or transforming states.\n\n4. **Logical Consistency**:\n   - Maintains consistency by ensuring that the preconditions and effects logically lead from a state needing covering to a covered state, applicable to various contexts.",
    "The goal is to merge the given actions into a single, universal PDDL action named `treat` that maintains generality, reflects state changes, retains core logic, avoids redundancy, and ensures logical consistency. Here's how the merged action would look:\n\n```pddl\n(:action treat ; Treat a subject to change its state\n :parameters (?subject - entity ?object - feature)\n :precondition (and\n                 (requires_treatment ?subject ?object)\n                 (available_resources ?object)\n               )\n :effect (and\n           (treated ?subject ?object)\n           (not (requires_treatment ?subject ?object))\n         )\n)\n```\n\n### Explanation:\n\n- **Generality**: The action uses abstract parameters `?subject` and `?object` with types `entity` and `feature` respectively. This makes it applicable to a wide range of tasks that involve treating or transforming subjects with specific features or resources.\n\n- **State Change**: The precondition checks if the `?subject` requires treatment with the `?object` and if the necessary resources are available. The effect reflects the state change by marking the `?subject` as treated and removing the requirement for treatment.\n\n- **Core Logic**: The logic of preconditions and effects from original actions is retained but abstracted to be applicable to multiple scenarios.\n\n- **Avoid Redundancy**: Similar effects from different actions are combined, ensuring simplicity. For instance, transforming state changes like taming hair or twisting a braid can be captured as `treated`.\n\n- **Logical Consistency**: The merged action maintains consistent logic, ensuring that it has reasonable preconditions and effects in different contexts.\n\nThis universal `treat` action allows for adaptability and application across various tasks that involve modifying or transforming the state of an entity with the help of certain features or resources.",
    "To merge the given PDDL actions into a single universal action, we need to identify the common structure and abstract the parameters to ensure generality while maintaining logical consistency and avoiding redundancy. Here's how the merged action can be formulated:\n\n```pddl\n(:action create_style\n    :parameters (?agent - entity ?style - style ?material - material)\n    :precondition (and \n                    (has_ability ?agent ?style) \n                    (current_form ?material original)\n                    (desire_change ?agent ?style))\n    :effect (and \n              (current_form ?material ?style)\n              (not (current_form ?material original))\n              (style_applied ?agent ?style))\n)\n```\n\n### Explanation:\n\n1. **Generality**: The `create_style` action is designed to be adaptable to various tasks related to styling or creating using different materials (e.g., hair, fabric). The parameters `?agent`, `?style`, and `?material` are abstract, allowing flexibility in application.\n\n2. **State Change**: The precondition checks if the agent has the ability to apply the style and if there is a desire to change from the original form. The effect indicates that the material has been transformed to the desired style, reflecting a clear state change.\n\n3. **Simplicity**: The merged action combines similar effects (e.g., transforming natural hair into various braid styles) and removes unnecessary complexity by using a generalized approach to describe the transformation.\n\n4. **Logical Consistency**: The preconditions and effects maintain a logical flow, ensuring that an agent can only apply a style if they have the ability and desire to do so. The action reflects a reasonable sequence of tasks across different contexts.\n\nThis universal action, `create_style`, effectively captures the essence of the original actions, focusing on the transformation process using abstract and adaptable parameters.",
    "To create a universal merged action called \"learn\" from the provided action sets, we need to abstract the parameters and generalize the preconditions and effects to cover a variety of learning tasks. Here's how the merged action could look:\n\n```lisp\n(:action learn ; Learn a skill or acquire knowledge\n  :parameters (?entity - agent ?skill - skill)\n  :precondition (and (not (knows ?entity ?skill)))\n  :effect (knows ?entity ?skill))\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The parameters are abstracted to `?entity` and `?skill` to represent any agent (e.g., npc, person) and any skill or knowledge that can be learned.\n   - This makes the action applicable to a wide range of scenarios beyond just braiding techniques.\n\n2. **State Change**:\n   - The precondition ensures that the `?entity` does not already possess the `?skill`.\n   - The effect reflects the change in state by indicating that the `?entity` now knows the `?skill`.\n\n3. **Simplicity**:\n   - The merged action avoids redundancy by using a single effect to cover all learning scenarios, reducing complexity.\n\n4. **Logical Consistency**: \n   - The preconditions and effects are reasonable and clear, maintaining consistency across different learning tasks.\n\nThis merged action can be adapted to any context where an agent learns a new skill, thus capturing the essence of the original actions while being broadly applicable.",
    "To merge the given actions into a single, universal action while adhering to the guidelines provided, we need to abstract the specifics of each action to create a generalized version that can apply broadly to various tasks. Here is how the merged action for \"braid\" can be constructed:\n\n```pddl\n(:action braid ; Braid an entity to modify its appearance\n    :parameters (?entity - object)\n    :precondition (and (decoration ?entity initial_state) (visibility ?entity initial_visibility))\n    :effect (and (decoration ?entity modified_state) (visibility ?entity modified_visibility))\n)\n```\n\n### Explanation:\n\n- **Generality**: The action is defined with abstract parameters (`?entity - object`) instead of specific types like `npc`, making it adaptable to various entities that can be \"braided\" or altered in appearance.\n\n- **State Change**: The preconditions (`decoration ?entity initial_state` and `visibility ?entity initial_visibility`) and effects (`decoration ?entity modified_state` and `visibility ?entity modified_visibility`) clearly depict a transformation from an initial to a modified state, capturing the core logic of the original actions.\n\n- **Simplicity and Avoiding Redundancy**: By focusing on abstract parameters and removing specific conditions and effects related to cornrows and visibility, the action remains simple and avoids unnecessary complexity.\n\n- **Logical Consistency**: The preconditions and effects maintain a logical progression from an unbraided (or initial) state to a braided (or modified) state while ensuring the action can be consistently interpreted in different contexts.\n\nThis merged action is designed to encapsulate the essence of \"braiding\" while keeping it applicable across a range of scenarios involving changes in decoration and visibility.",
    "Here is the merged action based on the given examples:\n\n```lisp\n(:action secure\n    :parameters (?entity - object ?resource - object)\n    :precondition (and \n                    (state ?entity initial)\n                    (location ?resource available)\n                  )\n    :effect (and \n              (state ?entity transformed)\n              (location ?resource utilized)\n            )\n)\n```\n\n### Explanation:\n\n1. **Generality**: The merged action uses abstract parameters such as `?entity` and `?resource`, making it applicable to a variety of tasks, whether it involves securing braids, organizing cornrows, or handling other objects and resources.\n\n2. **State Change**: The action clearly defines a state transformation from an `initial` state to a `transformed` state for the `?entity`, while the `?resource` changes its location from `available` to `utilized`, reflecting the completion of a task or securing of an object.\n\n3. **Core Logic**: The precondition checks if the `?entity` is in an initial state and the `?resource` is available, maintaining core logic without unnecessary complexity. The effect reflects the change in state, indicating the successful transformation or securing of the `?entity`.\n\n4. **Avoid Redundancy**: Similar actions with effects like securing, organizing, or transforming have been combined to avoid redundancy, focusing on the essential preconditions and effects.\n\n5. **Logical Consistency**: The merged action maintains logical consistency across different contexts by clearly defining the transition of states and the use of resources, ensuring that the action is applicable to various scenarios without losing its core logic.",
    "To merge the given PDDL actions into a universal action named \"divide,\" we need to consider the guidelines for generality, state change, core logic, avoidance of redundancy, and logical consistency. Here's how the merged action could look:\n\n```lisp\n(:action divide ; Divide an entity into distinct parts or states\n    :parameters (?entity - object ?context - context)\n    :precondition (and \n                    (divisible ?entity)\n                    (not (divided ?entity))\n                    (contextual_precondition ?entity ?context)\n                  )\n    :effect (and \n              (divided ?entity)\n              (contextual_effect ?entity ?context)\n            )\n)\n```\n\n### Explanation\n\n1. **Generality**: \n   - The action is named \"divide\" to be applicable to a wide range of tasks that involve dividing or separating an entity into parts.\n   - The parameters are abstract: `?entity` represents any object that can be divided, and `?context` represents any relevant context that might affect the division process.\n\n2. **State Change**:\n   - The precondition `(divisible ?entity)` ensures that the entity is in a state that allows division.\n   - The effect `(divided ?entity)` reflects the change in state, indicating that the entity has been successfully divided.\n\n3. **Core Logic**:\n   - The core logic of preconditions and effects is retained by using abstract predicates like `contextual_precondition` and `contextual_effect`, which can be specified further based on the task's domain.\n\n4. **Avoid Redundancy**:\n   - Similar effects across different actions are merged into a single effect `(divided ?entity)`, avoiding redundancy.\n\n5. **Logical Consistency**:\n   - The merged action maintains consistent logic across different tasks by using contextual predicates that can be defined in specific domains to ensure reasonable preconditions and effects.\n\nThis universal action \"divide\" can be adapted to various scenarios by defining the predicates `divisible`, `contextual_precondition`, and `contextual_effect` in the specific domain file. This allows the action to be reused across different tasks involving division or separation while maintaining logical consistency and simplicity.",
    "To merge the given PDDL actions into a single universal action named \"pull,\" we need to ensure that the action is general, captures the state change, retains core logic, avoids redundancy, and maintains logical consistency. Here's how we can achieve that:\n\n### Merged Action: Pull\n\n```lisp\n(:action pull ; Perform a pull operation and transform the state\n  :parameters (?entity - object ?state - state)\n  :precondition (and \n                  (current_state ?entity ?state)\n                  (not (desired_state ?entity))\n                )\n  :effect (desired_state ?entity)\n)\n```\n\n### Explanation\n\n1. **Generality:**\n   - The action uses abstract parameters `(?entity - object)` and `(?state - state)` to be applicable to various tasks involving pulling or transforming a state. This increases its adaptability across different contexts.\n\n2. **State Change:**\n   - The preconditions and effects clearly describe the state change. The precondition `(current_state ?entity ?state)` ensures that the action is only applicable when the entity is in a specific state, and the effect `(desired_state ?entity)` represents the transformed state, achieving the goal.\n\n3. **Core Logic:**\n   - The action retains the core logic of preconditions and effects from the original actions without unnecessary complexity, focusing on the transformation of the entity's state.\n\n4. **Avoid Redundancy:**\n   - The merged action eliminates redundancy by combining similar state transformations into a single coherent action.\n\n5. **Logical Consistency:**\n   - The action maintains logical consistency by ensuring that the preconditions and effects are reasonable across different tasks, capturing the essence of the original actions while providing a unified approach to state change.\n\nThis merged action is designed to handle various scenarios where an entity's state needs to be transformed through a \"pull\" operation, such as camouflaging a decoration or slipping beads. The use of abstract parameters allows it to be reused in different contexts, providing a flexible solution for state transformation tasks.",
    "Here is the merged action based on the provided actions and guidelines:\n\n```pddl\n(:action sweep ; Sweep or modify an entity's state\n:parameters (?n - npc ?attribute - property ?initial_state - state ?final_state - state)\n:precondition (and (?attribute ?n ?initial_state))\n:effect (and (?attribute ?n ?final_state))\n)\n```\n\n### Explanation:\n\n1. **Generality**: The merged action `sweep` uses abstract parameters such as `?attribute`, `?initial_state`, and `?final_state` to make it adaptable to a variety of tasks beyond just sweeping hair. This allows it to handle different types of state changes for any given entity.\n\n2. **State Change**: The precondition specifies an initial state of an attribute, and the effect describes the transformation to a final state, capturing the essence of both original actions.\n\n3. **Simplicity**: The merged action is simplified by using generic parameters and avoiding redundancy, capturing the core logic of altering an entity's state.\n\n4. **Logical Consistency**: The merged action maintains logical consistency by ensuring that the transformation from an initial state to a final state is clearly defined, without introducing unnecessary complexity or specific conditions that aren't universally applicable.",
    "To merge the actions into a single universal action called `start`, we aim to encapsulate the essence of starting a process and transitioning an entity from an initial state to a more advanced state. Here\u2019s how the merged action could look:\n\n```pddl\n(:action start ; Initiate a process and update its state\n    :parameters (?entity - object ?action - process)\n    :precondition (and (ready_to_start ?entity) (process_state ?entity not_started))\n    :effect (and (process_state ?entity started))\n)\n```\n\n### Explanation\n\n1. **Generality**: The merged action uses abstract parameters `?entity` and `?action`, which can represent any object or process, making the action adaptable to a wide range of tasks.\n\n2. **State Change**: The precondition `ready_to_start` and `process_state not_started` signify that the entity is prepared and the process has not begun. The effect `process_state started` indicates the transition to a started state. This captures the beginning of any process, similar to initiating a braid or starting other tasks.\n\n3. **Core Logic**: The action retains the core logic by ensuring the entity is in a \"ready\" state and then transitioning it to a \"started\" state, which is a fundamental requirement in initiating any process.\n\n4. **Avoid Redundancy**: This action merges similar effects from the given actions, focusing on the transition from not started to started, and avoids redundant preconditions or effects.\n\n5. **Logical Consistency**: The action is logically consistent across different contexts where a process needs to be started, maintaining clear and reasonable preconditions and effects.",
    "To merge the given actions into a single universal action called `add`, we need to create an abstract representation that is adaptable to various tasks that involve adding or modifying elements. The merged action will focus on capturing the essence of adding or modifying, with parameters and state changes generalized for broader applicability. Here's how the merged action can be structured:\n\n```lisp\n(:action add ; Add or modify an element to change its state\n    :parameters (?entity - object ?target - location)\n    :precondition (and \n        (ready_for_addition ?entity) \n        (suitable ?target)\n        (not (added ?entity ?target)))\n    :effect (and \n        (added ?entity ?target)\n        (updated_state ?entity ?target)\n        (not (ready_for_addition ?entity)))\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The parameters `?entity` and `?target` are abstract and can represent any object or location, respectively, making the action adaptable to a variety of tasks.\n   - The preconditions and effects are generalized to cover a broad range of adding or modifying scenarios.\n\n2. **State Change**:\n   - The action clearly describes the state change: an `entity` is added to a `target`, and its state is updated accordingly.\n\n3. **Simplicity**:\n   - Redundant preconditions and effects are avoided by focusing on the core logic of addition and state change.\n   - The action retains the essence of adding elements while remaining simple and efficient.\n\n4. **Logical Consistency**:\n   - The preconditions ensure that the `entity` is ready and the `target` is suitable for addition.\n   - The effects ensure the `entity` is added and its state is updated, maintaining logical consistency across different tasks.\n\nThis merged action can be applied to scenarios such as adding hair to a section, adding extensions, or modifying an element's state in various contexts, providing a versatile and coherent approach to task execution.",
    "The merged action for the provided action sets can be defined as follows:\n\n```pddl\n(:action cross ; Cross a section, panel, or entity and adjust its status\n    :parameters (?entity - entity_type)\n    :precondition (and \n        (or (selected ?entity) (unselected ?entity))\n        (or (unadjusted ?entity) (carefully_placed ?entity))\n    )\n    :effect (and \n        (crossed ?entity)\n        (selected ?entity)\n        (not (unselected ?entity))\n        (not (unadjusted ?entity))\n        (not (carefully_placed ?entity))\n    )\n)\n```\n\n### Explanation:\n\n1. **Generality:** \n   - The action is generalized to apply to any entity (`?entity`) of type `entity_type`, which could be a `section`, `panel`, or `npc`. This allows for broader applicability across different tasks.\n\n2. **State Change:**\n   - Preconditions ensure that the entity is either `selected` or `unselected`, and either `unadjusted` or `carefully_placed`. This captures the essence of all three original actions.\n   - The effects transition the entity to a `crossed` state while ensuring it is `selected`, and it removes the `unselected`, `unadjusted`, and `carefully_placed` conditions.\n\n3. **Simplicity:**\n   - The merged action avoids redundancy by combining similar logic from the original actions, reducing complexity while maintaining functionality.\n\n4. **Logical Consistency:**\n   - Preconditions and effects are logically consistent to cover the scenarios from all original actions, ensuring the action can be applied in different contexts with reasonable outcomes.",
    "To merge the provided PDDL actions into a single, universal action named \"bend,\" we'll adhere to the guidelines of generality, state change, simplicity, and logical consistency. Here is the merged action based on the provided tasks:\n\n```lisp\n(:action bend ; Bend a material or object into the desired state\n  :parameters (?npc - person ?material - object)\n  :precondition (and\n                  (ready-to-bend ?npc ?material)\n                  (not (bent ?material))\n                )\n  :effect (bent ?material)\n)\n```\n\n### Explanation of the Merged Action:\n\n1. **Generality:**\n   - The action uses abstract parameters (`?npc - person` and `?material - object`) to ensure it can apply to various tasks involving bending different types of materials or objects.\n\n2. **State Change:**\n   - The preconditions ensure that the person (`?npc`) is ready, and the material is in a state that requires bending (`ready-to-bend ?npc ?material`).\n   - The effect clearly transitions the state of the material to `bent ?material`, indicating the task's completion.\n\n3. **Simplicity:**\n   - The action is straightforward, with only essential preconditions and effects, avoiding unnecessary complexity or redundancy.\n   - The merging process considers that both `bend-to-shape-twice` and any other similar actions involve transitioning an object from a non-bent to a bent state.\n\n4. **Logical Consistency:**\n   - The merged action maintains logical consistency by ensuring that the preconditions are reasonable and the effects directly correlate to the intended state change.\n   - The action is designed to be adaptable to various contexts where bending is required, maintaining its utility across different scenarios.\n\nBy following these guidelines, the merged action is versatile, efficient, and logically sound, making it suitable for a wide range of tasks.",
    "To create a merged action for the \"brush\" task, we'll aim for generality and simplicity while ensuring logical consistency and clear state changes. Here's how the merged action could be structured:\n\n```pddl\n(:action brush ; Brush an entity to change its state from tangled to smooth\n    :parameters (?entity - object)\n    :precondition (and (state ?entity tangled))\n    :effect (and (state ?entity smooth))\n)\n```\n\n### Explanation:\n\n1. **Generality:** \n   - The parameter `?entity` is abstract, allowing it to apply to various objects beyond just \"hair\" or \"person.\" This makes the action adaptable for different tasks that involve \"brushing\" or \"smoothing\" any kind of entity.\n\n2. **State Change:**\n   - The precondition `(state ?entity tangled)` and effect `(state ?entity smooth)` clearly describe the transformation from a \"tangled\" state to a \"smooth\" state.\n\n3. **Simplicity:**\n   - The action avoids unnecessary complexity by focusing solely on the essential precondition and effect needed to perform the task.\n\n4. **Logical Consistency:**\n   - The logic of the action remains consistent within the context of changing an entity's state, ensuring that the transformation process is clear and reasonable.\n\nThis merged action maintains the core logic of transforming an entity's state from \"tangled\" to \"smooth,\" while being versatile enough to apply to a wide range of tasks involving similar state changes.",
    "When merging PDDL actions into a universal action, the goal is to create a flexible and abstract representation that can adapt to various contexts while maintaining logical consistency and simplicity. In the example provided, the focus is on merging actions related to checking and updating statuses. Let's apply similar principles to merge the \"PartHair\" action:\n\n### Action Name After Merge: ModifyAttribute\n\nGiven the example of the \"PartHair\" action, we can generalize it to a broader action that modifies an attribute of an entity. Here's how you can define it:\n\n```lisp\n(:action ModifyAttribute\n  :parameters (?entity - entity ?attribute - attribute)\n  :precondition (not (has_attribute ?entity ?attribute))\n  :effect (has_attribute ?entity ?attribute))\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The action is named `ModifyAttribute`, which is a broad term that can apply to various scenarios where an attribute of an entity needs to be changed.\n   - Parameters are generalized to `?entity` and `?attribute`, allowing the action to be applied to any entity and any attribute.\n\n2. **State Change**:\n   - The precondition checks if the entity does not already have the specified attribute (`(not (has_attribute ?entity ?attribute))`).\n   - The effect is to assign the attribute to the entity (`(has_attribute ?entity ?attribute)`).\n\n3. **Simplicity**:\n   - The action is straightforward, with a single precondition and a single effect, avoiding unnecessary complexity.\n   - Redundancies are avoided by using abstract terms that cover a wide range of possible scenarios.\n\n4. **Logical Consistency**:\n   - The logical structure of the action is consistent across different contexts, focusing on the change of an entity's attribute state.\n   - Preconditions and effects are clearly defined to ensure that the action makes sense in any situation where an attribute needs to be modified.\n\nBy using this approach, the `ModifyAttribute` action can be applied to various tasks involving attribute changes, such as parting hair, assigning roles, or updating statuses, thereby achieving a flexible and adaptable universal action.",
    "(:action GrabSmallSection ; Grab a small section and mark it as selected\n:parameters (?actor - entity ?section - section)\n:precondition (and (parted ?actor) (not (selected ?section)))\n:effect (selected ?section))",
    "To merge the provided action set into a single universal action while adhering to the guidelines, we should focus on creating an abstract and adaptable action that can apply to various tasks involving section division. Here's how the merged action could look:\n\n```pddl\n(:action DivideSection ; Universally divide a section into subsections\n    :parameters (?entity - object ?context - context)\n    :precondition (and (selected ?entity) (contextual_condition ?context))\n    :effect (divided ?entity))\n```\n\n### Explanation:\n\n1. **Generality:**\n   - **Parameters:** The parameters are abstract (`?entity - object` and `?context - context`), allowing the action to apply to any object that represents a section within a given context. This abstraction makes it flexible to handle different types of sections beyond just the original \"section\" concept.\n\n2. **State Change:**\n   - **Precondition:** The action requires the entity to be selected and a contextual condition to be met (`contextual_condition ?context`). This ensures that the section is ready to be divided and that any necessary conditions related to the broader context are satisfied.\n   - **Effect:** The effect is that the entity becomes divided (`divided ?entity`). This clearly describes the transformation of the entity's state.\n\n3. **Simplicity:**\n   - The action avoids unnecessary complexity by having straightforward preconditions and effects. It does not include any redundant checks or conditions that do not contribute directly to the action's purpose.\n\n4. **Logical Consistency:**\n   - The action maintains logical consistency by ensuring that the preconditions and effects are reasonable and applicable across different contexts. The context parameter allows the action to adapt its logic based on where and how it's applied.\n\nBy using abstract parameters and maintaining clear state changes, this merged action is both simple and adaptable to a variety of tasks requiring the division of sections.",
    "To create a merged action from the provided action sets for \"TieStrandsIntoKnot,\" we need to follow the guidelines to ensure generality, simplicity, logical consistency, and clear state changes. Here's how we can combine the action sets:\n\n### Merged Action\n\n```lisp\n(:action TieStrandsIntoKnot\n    :parameters (?entity - entity ?section - section)\n    :precondition (and (divided ?section) (not (knotted ?entity ?section)))\n    :effect (knotted ?entity ?section)\n)\n```\n\n### Explanation\n\n1. **Generality**: \n   - The parameters are made more abstract by using `?entity` and `?section` instead of specific types like `?n - npc`. This ensures that the action can apply to a wider range of entities and sections, increasing its adaptability to various contexts.\n\n2. **State Change**:\n   - The precondition `(divided ?section)` indicates that the section is initially divided.\n   - The effect `(knotted ?entity ?section)` indicates the transformation of the state where the entity ties the divided section into a knot.\n\n3. **Core Logic**:\n   - The precondition checks if the section is divided. This ensures that the action only applies when a section needs to be tied.\n   - The effect clearly states the outcome of the action, which is the section being knotted by the entity.\n\n4. **Avoid Redundancy**:\n   - The precondition `(not (knotted ?entity ?section))` is added to avoid redundancy, ensuring the section is not already knotted by the entity before performing the action.\n\n5. **Logical Consistency**:\n   - The action maintains a logical flow by ensuring that the preconditions are met before the change in the state is applied.\n   - This consistency ensures the action can be used in different contexts without logical conflicts.\n\nBy following these principles, the merged action is more versatile, efficient, and applicable to various scenarios involving tying sections into knots.",
    "To merge the given action into a universal action that maintains generality, reflects state change, avoids redundancy, and maintains logical consistency, we need to consider the abstract parameters and the common logic of the action. Below is the merged action based on the provided example and guidelines:\n\n```pddl\n(:action AddHairToStrand ; Add a feature to an entity and update its status\n    :parameters (?entity - object ?feature - feature)\n    :precondition (and (has_state ?entity ?initial_state))\n    :effect (and (updated_state ?entity ?new_state))\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The parameters `?entity` and `?feature` are abstract, which allows the action to be applied to a variety of tasks involving different types of entities and features.\n   \n2. **State Change**: \n   - The precondition `(has_state ?entity ?initial_state)` and the effect `(updated_state ?entity ?new_state)` clearly describe the transformation of the entity's state from an initial state to a new state.\n   \n3. **Simplicity**:\n   - The action avoids redundancy by using a general state transformation framework rather than specific states like `knotted` or `reinforced`, which can apply to broader contexts.\n   \n4. **Logical Consistency**:\n   - The logic is consistent and reasonable, ensuring the preconditions and effects are clear and applicable across different scenarios by using abstract state descriptions (`?initial_state`, `?new_state`).\n\nThis merged action could be adapted to handle the addition of various features to different entities, reflecting the transition of states in a manner applicable to a wide range of tasks.",
    "To merge the provided actions into a single, universal action named `TieStrandsAgain`, we'll follow the guidelines outlined for generality, state change, simplicity, and logical consistency. The actions provided are already quite similar, which makes the merging process straightforward. Here's how the merged action looks:\n\n```pddl\n(:action TieStrandsAgain ; Tie strands again to form a strong knot\n    :parameters (?entity - object)\n    :precondition (reinforced ?entity)\n    :effect (knotted ?entity)\n)\n```\n\n### Explanation:\n\n1. **Generality**: The parameter `?entity` is used instead of `?n - npc` to increase the action's applicability to any object, not just NPCs.\n\n2. **State Change**: The precondition `(reinforced ?entity)` clearly indicates that the entity must be in a reinforced state before the action can occur. The effect `(knotted ?entity)` shows the transformation of the entity's state to being knotted.\n\n3. **Simplicity and Avoiding Redundancy**: The action is simple, as it combines the essence of tying strands again without additional complexity or redundancy.\n\n4. **Logical Consistency**: The action maintains logical consistency by ensuring that the precondition and effect are clear, reasonable, and contextually appropriate for a variety of tasks involving tying or knotting actions. \n\nThis universal action can now be applied to any object or context where tying or knotting is needed after reinforcement, providing flexibility and broad applicability.",
    "To merge the given action sets into a single, universal action named \"TieBraidOff,\" we should follow the provided guidelines to ensure generality, clarity in state change, simplicity, and logical consistency. Here is the merged action:\n\n```pddl\n(:action TieBraidOff\n    :parameters (?entity - object)\n    :precondition (knotted ?entity)\n    :effect (braided ?entity)\n)\n```\n\nExplanation:\n\n1. **Generality**: The action uses abstract parameters (`?entity - object`) to be applicable to a variety of tasks involving objects that can be tied or braided, not limited to specific types like NPCs.\n\n2. **State Change**: The precondition `(knotted ?entity)` indicates the current state that must be satisfied for the action to proceed. The effect `(braided ?entity)` describes the transformation of the entity's state, achieving the goal of having it braided.\n\n3. **Simplicity**: The action is straightforward, with no unnecessary complexity, capturing the essence of changing an object's state from knotted to braided.\n\n4. **Logical Consistency**: The logic is consistent across potential tasks that involve tying or braiding, maintaining reasonable preconditions and effects.\n\nThis merged action effectively encapsulates the core logic and purpose of the original actions, allowing for a wide range of applications in different contexts.",
    "To merge the given actions into a single universal action while adhering to the guidelines of generality, simplicity, and logical consistency, we need to abstract the parameters and ensure the merged action is adaptable to various tasks. Here is the merged action for the \"GatherHair\" task:\n\n### Merged Action: GatherTransform\n\n```pddl\n(:action GatherTransform ; Transform an entity's state from one form to another\n    :parameters (?entity - object ?state1 - state ?state2 - state)\n    :precondition (and (not (?state2 ?entity)) (?state1 ?entity))\n    :effect (and (?state2 ?entity) (not (?state1 ?entity)))\n)\n```\n\n### Explanation:\n\n1. **Generality:**\n   - The action uses abstract parameters `?entity`, `?state1`, and `?state2` to represent any object and its states, which allows it to be applied to a variety of tasks beyond just gathering hair.\n   - This abstraction makes the action adaptable to different domains where an entity's state needs to be transformed.\n\n2. **State Change:**\n   - The precondition ensures that the entity is currently in `state1` and not in `state2`, reflecting the need for a state transition.\n   - The effect describes the transformation from `state1` to `state2`, ensuring a clear state change.\n\n3. **Simplicity and Avoiding Redundancy:**\n   - By using a single action to represent the transformation between states, redundancy is minimized.\n   - The action is kept simple by focusing solely on the state change logic without extraneous conditions.\n\n4. **Logical Consistency:**\n   - The action maintains a logical flow by ensuring that an entity cannot be in both `state1` and `state2` simultaneously.\n   - Preconditions and effects are consistently defined to maintain clarity across different contexts.\n\nThis merged action can be adapted for tasks requiring state transitions, such as transforming a plain hairstyle to a braided one, or any other similar transformations in different domains.",
    "To create a merged PDDL action for \"TwistIntoBun\" that captures the logical sequence and state transitions for a variety of tasks related to hair styling, we need to abstract the parameters and actions to achieve generality and avoid redundancy. Here's how the merged action might look:\n\n```pddl\n(:action TwistIntoBun\n    :parameters (?entity - object ?style - hairstyle)\n    :precondition (and (prepared ?entity) (not (styled ?entity ?style)))\n    :effect (and (styled ?entity ?style) (secured ?style))\n)\n```\n\n### Explanation:\n\n**Generality**: \n- The action uses abstract parameters `?entity` and `?style` to apply to a broader range of scenarios. This allows the action to be adaptable to different types of objects (e.g., hair, fabric) and styles (e.g., bun, braid).\n\n**State Change**:\n- The precondition `(prepared ?entity)` represents the entity being ready for styling, which could encompass actions like gathering or parting in the context of hair.\n- The effect `(styled ?entity ?style)` indicates that the entity has been styled into the desired form, capturing the transformation from a prepared state to a styled state.\n- The effect `(secured ?style)` ensures that the styled form is stable and complete, akin to tying off a braid or securing a bun.\n\n**Simplicity**:\n- By avoiding specific references to hair or buns, the action is made simple and versatile, capturing the essence of styling without unnecessary complexity.\n\n**Logical Consistency**:\n- The preconditions and effects are logically consistent across different tasks, maintaining the core logic of transforming an entity's state from prepared to styled and secured.\n\nThis merged action can be used in various contexts where an object needs to be prepared and secured into a specific style, not limited to hair styling.",
    "To merge the given action sets into a single, universal PDDL action named \"PullHair,\" we need to ensure that it adheres to the guidelines of generality, state change, simplicity, and logical consistency. Below is the merged action:\n\n```pddl\n(:action PullHair ; Modify the state of an entity by altering its properties\n    :parameters (?entity - object ?tool - tool)\n    :precondition (and (prepared ?entity) (attached ?tool))\n    :effect (and (modified ?entity) (used ?tool) (not (attached ?tool)))\n)\n```\n\n### Explanation:\n\n- **Generality:** \n  - The parameters are abstracted to `?entity` and `?tool` to apply to a variety of tasks, not just those related to hair pulling. This makes the action adaptable to different scenarios where an entity's properties are altered using a tool.\n  \n- **State Change:**\n  - Preconditions reflect a prepared entity and an attached tool, indicating readiness for modification.\n  - Effects demonstrate the transformation: the entity is modified, the tool is used, and the attachment is removed.\n\n- **Simplicity:**\n  - Redundant elements are removed, focusing on the core logic of preparing an entity, using a tool, and updating the state accordingly.\n\n- **Logical Consistency:**\n  - Maintains reasonable logic by ensuring that the action can only occur when the entity and tool are in the appropriate initial states (i.e., prepared and attached, respectively).\n  - The effects are clear and ensure that the state change is meaningful in a variety of contexts.\n\nThis merged action is designed to represent a general operation of modifying an entity's state, capturing the essence of the original actions while extending applicability.",
    "To create a merged action called \"ContinueBraiding\" from the provided actions, which involves a sequence of hair braiding tasks, we will aim to incorporate the core logic, state changes, and ensure it is generalized for adaptability. Below is the proposed merged action:\n\n```pddl\n(:action ContinueBraiding\n    :parameters (?n - npc ?tool - object)\n    :precondition (and (or (plain ?n) (braided ?n)) (not (invisible ?n)))\n    :effect (and \n        (when (plain ?n) (and (braided ?n) (not (plain ?n))))\n        (when (and (braided ?n) (attached ?tool)) (and (camouflaged ?n) (not (attached ?tool))))\n        (when (and (camouflaged ?n) (braided ?n)) (invisible ?n))\n    )\n)\n```\n\n### Explanation:\n\n1. **Parameters**: The merged action involves a non-player character (`?n`) and a tool (`?tool`) such as scissors, which might be used in the braiding process.\n\n2. **Preconditions**:\n   - The character's hair must either be plain or already braided, but not yet invisible. This ensures that the action can be applied at any stage of the braiding process.\n   - The tool must be attached when transitioning from braided to camouflaged.\n\n3. **Effects**:\n   - If the hair is plain, it becomes braided.\n   - If the hair is braided and the tool is attached, the hair becomes camouflaged, and the tool is no longer attached.\n   - If the hair is camouflaged and braided, it becomes invisible, indicating the completion of the process.\n\n### Key Features:\n- **Generality**: The action uses abstract parameters (`?n` and `?tool`) and is adaptable to different NPCs and tools.\n- **State Change**: The action progresses through stages: plain to braided, braided to camouflaged, and camouflaged to invisible.\n- **Simplicity and Logical Consistency**: Each transition is clearly defined, avoiding unnecessary complexity and maintaining logical consistency across different stages of the task.",
    "To merge the given action into a more universal action under the name \"re,\" we want to ensure that the action can be applied to a variety of tasks involving redoing or repairing something. Let's create an adaptable action that captures this general concept:\n\n```pddl\n(:action re ; Redo or repair an entity to improve its condition\n  :parameters (?agent - person ?entity - object)\n  :precondition (and (needs_repair ?entity) (can_repair ?agent ?entity))\n  :effect (and (repaired ?entity) (not (needs_repair ?entity)))\n)\n```\n\n### Explanation:\n\n1. **Generality:** The parameters `?agent` and `?entity` are abstract, allowing the action to apply to any scenario where an entity needs to be redone or repaired by an agent. This action is not limited to specific types of objects or repairs.\n\n2. **State Change:** The precondition `(needs_repair ?entity)` signifies that the entity is in a state needing repair, and the effect `(repaired ?entity)` indicates that the entity has been repaired. The state change is clear and reflects the transformation from needing repair to being repaired.\n\n3. **Core Logic:** The precondition `(can_repair ?agent ?entity)` ensures that the agent is capable of performing the repair, maintaining logical consistency and practicality.\n\n4. **Avoid Redundancy:** The action is simplified to focus on the essential elements of redoing or repairing, avoiding unnecessary complexity or redundancy.\n\n5. **Logical Consistency:** The action maintains logical consistency by ensuring that an agent must be capable of repairing the entity, and that the need for repair is resolved in the effects. This logic can be applied across various contexts where something needs to be redone or fixed.",
    "Given the provided tasks and the guidelines for merging PDDL actions into a single universal action, let's create a merged action called `sliplargerbeads`. The goal is to encapsulate the core logic, maintain generality, and ensure logical consistency while reflecting the necessary state changes. Here is how the merged action can be defined:\n\n```pddl\n(:action sliplargerbeads ; Organize and position items from disordered to ordered state\n    :parameters (?entity - entity ?container - container)\n    :precondition (and (location ?entity off ?container) (organization ?entity random))\n    :effect (and (location ?entity on ?container) (organization ?entity ordered))\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The action uses abstract parameters `?entity` and `?container` instead of specific ones like `?c - cornrows`. This allows the action to be adaptable to various contexts and tasks where entities need to be organized or moved.\n\n2. **State Change**:\n   - Preconditions specify that the entity is initially `off` the container and in a `random` organization state.\n   - Effects describe the transformation of the entity to be `on` the container and organized in an `ordered` manner.\n\n3. **Simplicity**:\n   - The merged action avoids redundancy by using generic parameters and succinctly describing the state change without extraneous conditions or effects.\n\n4. **Logical Consistency**:\n   - The action maintains logical consistency by ensuring that the preconditions logically lead to the effects. The preconditions and effects are clearly defined and reasonable for tasks involving organization and positioning.\n\nThis universal action can be applied to scenarios involving organizing and positioning items, such as arranging beads, organizing books on a shelf, or any similar tasks where items are moved from a disordered to an ordered state.",
    "Here is the merged action for the braiding task, combining the provided PDDL actions into a single, generalized action:\n\n```lisp\n(:action braiding ; Braid a resource to change its state\n :parameters (?entity - object)\n :precondition (and \n                 (entity_state ?entity initial_state)\n                 (visibility ?entity visible)\n               )\n :effect (and\n           (entity_state ?entity transformed_state)\n           (visibility ?entity invisible)\n         )\n)\n```\n\n### Explanation\n\n- **Generality**: The action uses the parameter `?entity` of type `object` to generalize across different entities that may be braided, like `npc` or `equipment`, making it adaptable to various tasks.\n- **State Change**: The precondition checks if the entity is in an `initial_state`, which could correspond to `bare` for decorations or `unorganized` for equipment. The effect transforms the entity into a `transformed_state`, such as `camouflaged` or `organized`.\n- **Core Logic**: The logic of transforming the state of an entity while handling visibility (if applicable) is retained without unnecessary complexity.\n- **Avoid Redundancy**: Similar effects like `decoration` and `equipment_state` are merged into a single state change descriptor `entity_state` to ensure simplicity.\n- **Logical Consistency**: The action maintains logical consistency by ensuring that the preconditions and effects are reasonable and applicable in different contexts, such as changing visibility if relevant.",
    "To merge the provided actions into a single universal action that captures the essence of the tasks while adhering to the given guidelines, let's consider the abstract nature, state changes, simplicity, and logical consistency. Since the example actions are about transforming a state or checking a status, the merged action should maintain these characteristics.\n\nHere's how the merged action could look:\n\n```pddl\n(:action transform_state\n    :parameters (?entity - thing ?descriptor - attribute)\n    :precondition (not (has_attribute ?entity ?descriptor))\n    :effect (has_attribute ?entity ?descriptor)\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The action `transform_state` uses abstract parameters `?entity` and `?descriptor`, making it adaptable to a variety of tasks. The parameters are not limited to specific entities or attributes, thus providing a flexible framework for diverse applications.\n\n2. **State Change**:\n   - The precondition checks if the `?entity` lacks the `?descriptor` attribute. The effect then applies this attribute to the entity, illustrating a clear transformation of state.\n\n3. **Simplicity**:\n   - The action avoids redundancy by using a single abstract parameter set, simplifying the logic without unnecessary complexity.\n\n4. **Logical Consistency**:\n   - The precondition and effect are consistent across different contexts. They ensure that the action only applies the desired attribute if it is not already present, preserving logical consistency.\n\nThis merged action can be adapted to tasks involving checking, modifying, or creating a state in various domains, aligning with the guidelines provided.",
    "To create a merged action for the task \"SeparateHair,\" we need to consider the guidelines for merging actions, even though we have only one action to merge in this case. We will ensure that the action is general, captures the necessary state change, and maintains simplicity and logical consistency. Here's how the action can be defined:\n\n```pddl\n(:action transform_state ; General action to transform the state of an entity\n  :parameters (?entity - object ?attribute - attribute_type)\n  :precondition (and (current_state ?entity ?attribute) (not (target_state ?entity ?attribute)))\n  :effect (target_state ?entity ?attribute)\n)\n```\n\n### Explanation:\n\n1. **Generality:** \n   - The action is named `transform_state`, which is a general name reflecting the task of transforming an entity's state.\n   - The parameters are abstract, using `?entity` to refer to any object and `?attribute` to refer to any characteristic or state of that object. This allows the action to be applicable to various tasks involving state changes.\n\n2. **State Change:**\n   - The precondition checks if the entity is in the `current_state` for a given `?attribute` and ensures it has not already reached the `target_state`.\n   - The effect signifies the transition to the `target_state`, reflecting the state change.\n\n3. **Simplicity and Logical Consistency:**\n   - The action is straightforward, with clear preconditions and effects, maintaining logical consistency in its application to different tasks.\n   - By using abstract parameters, the action avoids redundancy and unnecessary complexity.\n\nIn the context of the provided example, this merged action can be adapted to separate hair or any other transformation task by specifying the appropriate `?entity` and `?attribute` in the domain definition.",
    "To merge the given action into a universal action named \"PlaitAsNormal\" while maintaining the guidelines of generality, state change, simplicity, and logical consistency, we can define the merged action as follows:\n\n```lisp\n(:action PlaitAsNormal ; Perform a standard task on an entity and update its status\n    :parameters (?entity - object ?task - task)\n    :precondition (and (ready_for_task ?entity ?task) (not (completed ?entity ?task)))\n    :effect (completed ?entity ?task)\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The merged action uses abstract parameters `?entity` and `?task` to apply to a variety of tasks beyond just plaiting. This allows it to be used for any standard task that an entity might perform.\n\n2. **State Change**: \n   - The precondition ensures the entity is ready for the task (`ready_for_task ?entity ?task`) and that the task hasn't yet been completed (`not (completed ?entity ?task)`). \n   - The effect reflects the completion of the task (`completed ?entity ?task`).\n\n3. **Simplicity**:\n   - The action is simplified to focus on the core logic of task completion without unnecessary complexity or specificity to a single task like plaiting.\n\n4. **Logical Consistency**:\n   - The preconditions and effects maintain logical consistency by ensuring that an entity can only complete a task if it is ready and hasn't completed it yet. This logic is applicable across different contexts and tasks.",
    "To create a merged action that encapsulates the logic of the given actions for the task of securing a braid, we need to generalize the parameters and ensure clarity in state transitions. Here\u2019s how the merged action might look:\n\n```pddl\n(:action SecureBraid ; Secure a braid by following sequential state transformations\n  :parameters (?n - npc ?h - hair)\n  :precondition (and (not (smooth ?h)) (not (secured ?h)))\n  :effect\n    (and\n      (smooth ?h)\n      (separated ?h)\n      (plaited ?h)\n      (secured ?h)\n    )\n)\n```\n\n### Explanation:\n\n1. **Generality**:\n   - The action uses abstract parameters `?n` for the NPC and `?h` for hair, allowing it to be applied to various NPCs and their hair.\n\n2. **State Change**:\n   - The action captures the progression from non-smooth to secured hair, reflecting each state change: smoothing, separating, plaiting, and securing.\n\n3. **Core Logic**:\n   - Preconditions ensure the hair is not already smooth or secured, maintaining logical consistency.\n   - Effects encompass all necessary transformations, achieving the goal state in one action.\n\n4. **Simplicity**:\n   - The action combines steps into a single sequence, reducing redundancy and complexity.\n\n5. **Logical Consistency**:\n   - Preconditions and effects are clearly defined, ensuring the action is logical and applicable in various contexts where hair needs to be secured. \n\nThis merged action effectively reflects the logical sequence necessary to transition hair through various states until it is secured, making it adaptable to different tasks involving hair management for NPCs.",
    "To create a universal action from the provided \"FashionBraidedLeather\" action, we will adapt it to be more general and applicable to a variety of similar tasks involving transforming an object's state from \"unprocessed\" to \"processed.\" Here is a merged and generalized version of the action:\n\n```lisp\n(:action process_material\n    :parameters (?material - object)\n    :precondition (and (not (processed ?material)) (unprocessed ?material))\n    :effect (and (processed ?material) (not (unprocessed ?material)))\n)\n```\n\n### Explanation:\n\n1. **Generality**: \n   - The action is renamed to `process_material` to indicate a broader range of applications. It can now apply to any object that undergoes a transformation from an unprocessed state to a processed state, not just leather being braided.\n\n2. **State Change**:\n   - The precondition checks if the material is currently in an `unprocessed` state and ensures it is not already `processed`.\n   - The effect then transforms the material to a `processed` state, ensuring the change is clear and consistent.\n\n3. **Simplicity and Avoiding Redundancy**:\n   - The action is streamlined to remove specific conditions like `whole` or `braided`, focusing instead on the general transformation states (`unprocessed` to `processed`).\n\n4. **Logical Consistency**:\n   - The preconditions and effects are logical and applicable to various tasks involving material processing, ensuring that the action can be reused in different contexts without modification.",
    "To merge the given PDDL actions into a single universal action called `MakeCompletedNecklace`, we need to ensure that the merged action retains generality, reflects clear state changes, avoids redundancy, and maintains logical consistency. Here's how the merged action might look:\n\n### Merged Action\n\n```pddl\n(:action MakeCompletedNecklace\n    :parameters (?entity - object ?state1 - state ?state2 - state)\n    :precondition (and (not (?state2 ?entity)) (?state1 ?entity))\n    :effect (and (?state2 ?entity) (not (?state1 ?entity)))\n)\n```\n\n### Explanation\n\n1. **Generality**: \n   - The merged action uses abstract parameters `?entity`, `?state1`, and `?state2` to generalize the action. This allows it to be adaptable to a variety of tasks, such as completing a necklace or any other object transformation tasks.\n\n2. **State Change**: \n   - The precondition specifies that the entity is not in the `state2` (e.g., not completed) and is currently in `state1` (e.g., camouflaged). The effect then transitions the entity from `state1` to `state2`.\n\n3. **Simplicity and Avoiding Redundancy**: \n   - The action avoids any unnecessary complexity by directly describing the transition from one state to another without additional conditions or effects.\n\n4. **Logical Consistency**: \n   - The action maintains a consistent logic structure, ensuring that any object transitioning from a `state1` to a `state2` is handled in a straightforward manner. The preconditions and effects are clear and reasonable across different contexts.\n\nThis merged action can be used to describe a variety of tasks where an object needs to be transitioned from one state to another, such as completing, processing, or transforming an item.",
    "To create a universal action that combines the given PDDL actions into \"UseAsLeatherRing,\" we need to abstract the parameters and unify the state transformations while ensuring logical consistency. Here's how the merged action would look:\n\n```pddl\n(:action TransformAndUseResource\n    :parameters (?resource - object ?form - state ?use - state)\n    :precondition (and (in_state ?resource ?form) (not (in_state ?resource ?use)))\n    :effect (in_state ?resource ?use)\n)\n```\n\n### Explanation:\n\n1. **Generality**:\n   - The action is named \"TransformAndUseResource\" to reflect a broader range of tasks that involve transforming a resource into a usable item.\n   - Abstract parameters are used, such as `?resource` for any object, `?form` for any initial state, and `?use` for the desired state after the transformation.\n\n2. **State Change**:\n   - Preconditions specify that the resource must be in a certain state (`?form`) and not yet in the state of use (`?use`).\n   - The effect is a state change where the resource is now in the desired use state (`?use`).\n\n3. **Simplicity and Avoiding Redundancy**:\n   - The action is streamlined to include only the necessary preconditions and effects, removing any complexities that aren't essential to the state transformation.\n\n4. **Logical Consistency**:\n   - The logical flow is maintained by ensuring that the preconditions logically lead to the effect, applicable to various tasks like braiding leather or completing a necklace.\n\nThis merged action can handle scenarios like:\n- Transforming braided leather into a ring (`?resource - leather`, `?form - braided`, `?use - used_as_ring`).\n- Completing a camouflaged necklace (`?resource - necklace`, `?form - camouflaged`, `?use - completed`).\n\nBy focusing on the abstract notion of state transformation, this action can be applied to a variety of crafting or usage tasks in a PDDL domain."
]